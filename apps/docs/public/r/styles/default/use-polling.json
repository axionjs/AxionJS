{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "use-polling",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-polling.ts",
      "content": "\"use client\";\nimport { useEffect, useRef, useCallback, useState, useReducer } from \"react\";\n\ninterface PollingOptions<T> {\n  /** The function to call on each polling interval */\n  fetchFn: () => Promise<T>;\n  /** Polling interval in milliseconds (default: 5000) */\n  interval?: number;\n  /** Whether to start polling immediately (default: true) */\n  autoStart?: boolean;\n  /** Maximum number of consecutive errors before stopping (default: Infinity) */\n  maxErrors?: number;\n  /** Whether to immediately run fetchFn on start (default: true) */\n  runImmediately?: boolean;\n  /** Initial data to use before first fetch completes */\n  initialData?: T;\n  /** Define custom error handling logic */\n  onError?: (error: Error) => void;\n  /** Callback when data is successfully fetched */\n  onSuccess?: (data: T) => void;\n  /** Check if response is considered an error */\n  isDataValid?: (data: T) => boolean;\n}\n\ntype PollingStatus = \"IDLE\" | \"POLLING\" | \"PAUSED\" | \"ERROR\" | \"STOPPED\";\n\ninterface PollingState<T> {\n  data: T | null;\n  error: Error | null;\n  status: PollingStatus;\n  lastUpdated: number | null;\n  errorCount: number;\n}\n\ntype PollingAction<T> =\n  | { type: \"START_POLLING\" }\n  | { type: \"PAUSE_POLLING\" }\n  | { type: \"STOP_POLLING\" }\n  | { type: \"FETCH_SUCCESS\"; payload: T }\n  | { type: \"FETCH_ERROR\"; payload: Error }\n  | { type: \"RESET_ERRORS\" };\n\n/**\n * Custom hook for polling an API endpoint at regular intervals\n *\n * @param options Configuration options for polling\n * @returns Object containing polling state and control functions\n */\nexport function usePolling<T>(options: PollingOptions<T>) {\n  const {\n    fetchFn,\n    interval = 5000,\n    autoStart = true,\n    maxErrors = Infinity,\n    runImmediately = true,\n    initialData = null as unknown as T,\n    onError,\n    onSuccess,\n    isDataValid,\n  } = options;\n\n  const initialState: PollingState<T> = {\n    data: initialData,\n    error: null,\n    status: \"IDLE\",\n    lastUpdated: null,\n    errorCount: 0,\n  };\n\n  const reducer = (\n    state: PollingState<T>,\n    action: PollingAction<T>,\n  ): PollingState<T> => {\n    switch (action.type) {\n      case \"START_POLLING\":\n        return {\n          ...state,\n          status: \"POLLING\",\n        };\n      case \"PAUSE_POLLING\":\n        return {\n          ...state,\n          status: \"PAUSED\",\n        };\n      case \"STOP_POLLING\":\n        return {\n          ...state,\n          status: \"STOPPED\",\n        };\n      case \"FETCH_SUCCESS\":\n        return {\n          ...state,\n          data: action.payload,\n          error: null,\n          lastUpdated: Date.now(),\n          errorCount: 0,\n          status: state.status === \"ERROR\" ? \"POLLING\" : state.status,\n        };\n      case \"FETCH_ERROR\":\n        const newErrorCount = state.errorCount + 1;\n        return {\n          ...state,\n          error: action.payload,\n          errorCount: newErrorCount,\n          status: newErrorCount >= maxErrors ? \"ERROR\" : state.status,\n        };\n      case \"RESET_ERRORS\":\n        return {\n          ...state,\n          errorCount: 0,\n          error: null,\n          status: state.status === \"ERROR\" ? \"POLLING\" : state.status,\n        };\n      default:\n        return state;\n    }\n  };\n\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isMountedRef = useRef(true);\n\n  const executeFetch = useCallback(async () => {\n    try {\n      const result = await fetchFn();\n\n      if (!isMountedRef.current) return;\n\n      if (isDataValid && !isDataValid(result)) {\n        throw new Error(\"Invalid data received\");\n      }\n\n      dispatch({ type: \"FETCH_SUCCESS\", payload: result });\n\n      if (onSuccess) {\n        onSuccess(result);\n      }\n    } catch (error) {\n      if (!isMountedRef.current) return;\n\n      const err =\n        error instanceof Error\n          ? error\n          : new Error(\"Unknown error during polling\");\n\n      dispatch({ type: \"FETCH_ERROR\", payload: err });\n\n      if (onError) {\n        onError(err);\n      }\n    }\n  }, [fetchFn, isDataValid, onSuccess, onError]);\n\n  const startPolling = useCallback(() => {\n    if (state.status === \"POLLING\") return;\n\n    dispatch({ type: \"START_POLLING\" });\n\n    if (runImmediately) {\n      executeFetch();\n    }\n\n    const poll = () => {\n      if (!isMountedRef.current || state.status !== \"POLLING\") return;\n\n      executeFetch().finally(() => {\n        if (isMountedRef.current && state.status === \"POLLING\") {\n          timeoutRef.current = setTimeout(poll, interval);\n        }\n      });\n    };\n\n    timeoutRef.current = setTimeout(poll, runImmediately ? interval : 0);\n  }, [state.status, executeFetch, interval, runImmediately]);\n\n  const pausePolling = useCallback(() => {\n    dispatch({ type: \"PAUSE_POLLING\" });\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  }, []);\n\n  const stopPolling = useCallback(() => {\n    dispatch({ type: \"STOP_POLLING\" });\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  }, []);\n\n  const resetErrors = useCallback(() => {\n    dispatch({ type: \"RESET_ERRORS\" });\n\n    if (state.status === \"ERROR\") {\n      startPolling();\n    }\n  }, [state.status, startPolling]);\n\n  const fetchNow = useCallback(() => {\n    if (state.status === \"POLLING\" || state.status === \"PAUSED\") {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n\n      executeFetch().finally(() => {\n        if (isMountedRef.current && state.status === \"POLLING\") {\n          timeoutRef.current = setTimeout(executeFetch, interval);\n        }\n      });\n    }\n  }, [state.status, executeFetch, interval]);\n\n  // Start polling on mount if autoStart is true\n  useEffect(() => {\n    if (autoStart) {\n      startPolling();\n    }\n\n    return () => {\n      isMountedRef.current = false;\n\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [autoStart, startPolling]);\n\n  return {\n    ...state,\n    isPolling: state.status === \"POLLING\",\n    isPaused: state.status === \"PAUSED\",\n    isStopped: state.status === \"STOPPED\",\n    isError: state.status === \"ERROR\",\n    startPolling,\n    pausePolling,\n    stopPolling,\n    resetErrors,\n    fetchNow,\n  };\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}