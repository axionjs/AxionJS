{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "use-polling",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-polling.ts",
      "content": "\"use client\";\r\nimport { useEffect, useRef, useCallback, useState, useReducer } from \"react\";\r\n\r\ninterface PollingOptions<T> {\r\n  /** The function to call on each polling interval */\r\n  fetchFn: () => Promise<T>;\r\n  /** Polling interval in milliseconds (default: 5000) */\r\n  interval?: number;\r\n  /** Whether to start polling immediately (default: true) */\r\n  autoStart?: boolean;\r\n  /** Maximum number of consecutive errors before stopping (default: Infinity) */\r\n  maxErrors?: number;\r\n  /** Whether to immediately run fetchFn on start (default: true) */\r\n  runImmediately?: boolean;\r\n  /** Initial data to use before first fetch completes */\r\n  initialData?: T;\r\n  /** Define custom error handling logic */\r\n  onError?: (error: Error) => void;\r\n  /** Callback when data is successfully fetched */\r\n  onSuccess?: (data: T) => void;\r\n  /** Check if response is considered an error */\r\n  isDataValid?: (data: T) => boolean;\r\n}\r\n\r\ntype PollingStatus = \"IDLE\" | \"POLLING\" | \"PAUSED\" | \"ERROR\" | \"STOPPED\";\r\n\r\ninterface PollingState<T> {\r\n  data: T | null;\r\n  error: Error | null;\r\n  status: PollingStatus;\r\n  lastUpdated: number | null;\r\n  errorCount: number;\r\n}\r\n\r\ntype PollingAction<T> =\r\n  | { type: \"START_POLLING\" }\r\n  | { type: \"PAUSE_POLLING\" }\r\n  | { type: \"STOP_POLLING\" }\r\n  | { type: \"FETCH_SUCCESS\"; payload: T }\r\n  | { type: \"FETCH_ERROR\"; payload: Error }\r\n  | { type: \"RESET_ERRORS\" };\r\n\r\n/**\r\n * Custom hook for polling an API endpoint at regular intervals\r\n *\r\n * @param options Configuration options for polling\r\n * @returns Object containing polling state and control functions\r\n */\r\nexport function usePolling<T>(options: PollingOptions<T>) {\r\n  const {\r\n    fetchFn,\r\n    interval = 5000,\r\n    autoStart = true,\r\n    maxErrors = Infinity,\r\n    runImmediately = true,\r\n    initialData = null as unknown as T,\r\n    onError,\r\n    onSuccess,\r\n    isDataValid,\r\n  } = options;\r\n\r\n  const initialState: PollingState<T> = {\r\n    data: initialData,\r\n    error: null,\r\n    status: \"IDLE\",\r\n    lastUpdated: null,\r\n    errorCount: 0,\r\n  };\r\n\r\n  const reducer = (\r\n    state: PollingState<T>,\r\n    action: PollingAction<T>,\r\n  ): PollingState<T> => {\r\n    switch (action.type) {\r\n      case \"START_POLLING\":\r\n        return {\r\n          ...state,\r\n          status: \"POLLING\",\r\n        };\r\n      case \"PAUSE_POLLING\":\r\n        return {\r\n          ...state,\r\n          status: \"PAUSED\",\r\n        };\r\n      case \"STOP_POLLING\":\r\n        return {\r\n          ...state,\r\n          status: \"STOPPED\",\r\n        };\r\n      case \"FETCH_SUCCESS\":\r\n        return {\r\n          ...state,\r\n          data: action.payload,\r\n          error: null,\r\n          lastUpdated: Date.now(),\r\n          errorCount: 0,\r\n          status: state.status === \"ERROR\" ? \"POLLING\" : state.status,\r\n        };\r\n      case \"FETCH_ERROR\":\r\n        const newErrorCount = state.errorCount + 1;\r\n        return {\r\n          ...state,\r\n          error: action.payload,\r\n          errorCount: newErrorCount,\r\n          status: newErrorCount >= maxErrors ? \"ERROR\" : state.status,\r\n        };\r\n      case \"RESET_ERRORS\":\r\n        return {\r\n          ...state,\r\n          errorCount: 0,\r\n          error: null,\r\n          status: state.status === \"ERROR\" ? \"POLLING\" : state.status,\r\n        };\r\n      default:\r\n        return state;\r\n    }\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n  const isMountedRef = useRef(true);\r\n\r\n  const executeFetch = useCallback(async () => {\r\n    try {\r\n      const result = await fetchFn();\r\n\r\n      if (!isMountedRef.current) return;\r\n\r\n      if (isDataValid && !isDataValid(result)) {\r\n        throw new Error(\"Invalid data received\");\r\n      }\r\n\r\n      dispatch({ type: \"FETCH_SUCCESS\", payload: result });\r\n\r\n      if (onSuccess) {\r\n        onSuccess(result);\r\n      }\r\n    } catch (error) {\r\n      if (!isMountedRef.current) return;\r\n\r\n      const err =\r\n        error instanceof Error\r\n          ? error\r\n          : new Error(\"Unknown error during polling\");\r\n\r\n      dispatch({ type: \"FETCH_ERROR\", payload: err });\r\n\r\n      if (onError) {\r\n        onError(err);\r\n      }\r\n    }\r\n  }, [fetchFn, isDataValid, onSuccess, onError]);\r\n\r\n  const startPolling = useCallback(() => {\r\n    if (state.status === \"POLLING\") return;\r\n\r\n    dispatch({ type: \"START_POLLING\" });\r\n\r\n    if (runImmediately) {\r\n      executeFetch();\r\n    }\r\n\r\n    const poll = () => {\r\n      if (!isMountedRef.current || state.status !== \"POLLING\") return;\r\n\r\n      executeFetch().finally(() => {\r\n        if (isMountedRef.current && state.status === \"POLLING\") {\r\n          timeoutRef.current = setTimeout(poll, interval);\r\n        }\r\n      });\r\n    };\r\n\r\n    timeoutRef.current = setTimeout(poll, runImmediately ? interval : 0);\r\n  }, [state.status, executeFetch, interval, runImmediately]);\r\n\r\n  const pausePolling = useCallback(() => {\r\n    dispatch({ type: \"PAUSE_POLLING\" });\r\n\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const stopPolling = useCallback(() => {\r\n    dispatch({ type: \"STOP_POLLING\" });\r\n\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const resetErrors = useCallback(() => {\r\n    dispatch({ type: \"RESET_ERRORS\" });\r\n\r\n    if (state.status === \"ERROR\") {\r\n      startPolling();\r\n    }\r\n  }, [state.status, startPolling]);\r\n\r\n  const fetchNow = useCallback(() => {\r\n    if (state.status === \"POLLING\" || state.status === \"PAUSED\") {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n        timeoutRef.current = null;\r\n      }\r\n\r\n      executeFetch().finally(() => {\r\n        if (isMountedRef.current && state.status === \"POLLING\") {\r\n          timeoutRef.current = setTimeout(executeFetch, interval);\r\n        }\r\n      });\r\n    }\r\n  }, [state.status, executeFetch, interval]);\r\n\r\n  // Start polling on mount if autoStart is true\r\n  useEffect(() => {\r\n    if (autoStart) {\r\n      startPolling();\r\n    }\r\n\r\n    return () => {\r\n      isMountedRef.current = false;\r\n\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, [autoStart, startPolling]);\r\n\r\n  return {\r\n    ...state,\r\n    isPolling: state.status === \"POLLING\",\r\n    isPaused: state.status === \"PAUSED\",\r\n    isStopped: state.status === \"STOPPED\",\r\n    isError: state.status === \"ERROR\",\r\n    startPolling,\r\n    pausePolling,\r\n    stopPolling,\r\n    resetErrors,\r\n    fetchNow,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}