{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "auth-actions",
  "type": "registry:auth",
  "author": "axionjs (https://www.axionjs.com)",
  "description": "Actions for handling authentication.",
  "dependencies": [
    "bcryptjs",
    "zod",
    "next-auth@beta",
    "cloudinary",
    "uuid"
  ],
  "registryDependencies": [
    "prisma"
  ],
  "files": [
    {
      "path": "auth/actions/auth-actions.ts",
      "content": "\"use server\";\n\nimport * as z from \"zod\";\nimport { db } from \"@/registry/default/auth/lib/db\";\nimport { v2 as cloudinary } from \"cloudinary\";\nimport {\n  LoginSchema,\n  NewPasswordSchema,\n  ResetSchema,\n  SettingsSchema,\n} from \"@/registry/default/auth/schemas\";\nimport { RegisterSchema } from \"@/registry/default/auth/schemas\";\nimport { getUserByEmail, getUserById } from \"@/registry/default/auth/lib/user\";\nimport { signIn, signOut } from \"@/registry/default/auth/lib/auth\";\nimport { DEFAULT_LOGIN_REDIRECT } from \"@/registry/default/auth/lib/routes\";\nimport { AuthError } from \"next-auth\";\nimport {\n  generatePasswordResetToken,\n  generateVerificationToken,\n  getPasswordResetTokenByToken,\n  getVerificationTokenByToken,\n  hashPassword,\n  verifyPassword,\n} from \"@/registry/default/auth/lib/auth-helpers\";\nimport {\n  sendPasswordResetEmail,\n  sendVerificationEmail,\n  sendTwoFactorTokenEmail,\n} from \"@/registry/default/auth/lib/mail\";\nimport {\n  generateTwoFactorToken,\n  getTwoFactorConfirmationByUserId,\n  getTwoFactorTokenByEmail,\n} from \"@/registry/default/auth/actions/two-factor\";\nimport { currentUser } from \"@/registry/default/auth/lib/get-user\";\n\nexport const login = async (\n  values: z.infer<typeof LoginSchema>,\n  callbackUrl?: string | null,\n) => {\n  const validatedFields = LoginSchema.safeParse(values);\n  if (!validatedFields.success) {\n    return { error: \"Invalid fields!\" };\n  }\n\n  const { email, password, code } = validatedFields.data;\n\n  const existingUser = await getUserByEmail(email);\n  if (!existingUser || !existingUser.email || !existingUser.password) {\n    // Either user/email does not exist or user signed in with OAuth\n    return { error: \"Email does not exist! / Sign in with OAuth!\" };\n  }\n\n  const passwordsMatch = await verifyPassword(password, existingUser.password);\n\n  if (!existingUser.emailVerified) {\n    const verificationToken = await generateVerificationToken(\n      existingUser.email,\n    );\n\n    if (!passwordsMatch) {\n      return { error: \"Invalid credentials!\" };\n    }\n    await sendVerificationEmail(\n      verificationToken.email,\n      verificationToken.token,\n    );\n\n    return { success: \"Confirmation email sent!\" };\n  }\n  if (!passwordsMatch) {\n    return { error: \"Invalid credentials!\" };\n  }\n  //2FA\n  if (existingUser.isTwoFactorEnabled && existingUser.email) {\n    if (code) {\n      const twoFactorToken = await getTwoFactorTokenByEmail(existingUser.email);\n\n      if (!twoFactorToken) return { error: \"Invalid code!\" };\n\n      if (twoFactorToken.token !== code) return { error: \"Invalid code!\" };\n\n      const hasExpired = new Date(twoFactorToken.expires) < new Date();\n\n      if (hasExpired) return { error: \"Code expired!\" };\n\n      await db.twoFactorToken.delete({ where: { id: twoFactorToken.id } });\n\n      const existingConfirmation = await getTwoFactorConfirmationByUserId(\n        existingUser.id,\n      );\n\n      if (existingConfirmation) {\n        await db.twoFactorConfirmation.delete({\n          where: { id: existingConfirmation.id },\n        });\n      }\n\n      await db.twoFactorConfirmation.create({\n        data: {\n          userId: existingUser.id,\n        },\n      });\n    } else {\n      const twoFactorToken = await generateTwoFactorToken(existingUser.email);\n      await sendTwoFactorTokenEmail(twoFactorToken.email, twoFactorToken.token);\n\n      // when 2FA token has been emailed to user\n      return { twoFactor: true };\n    }\n  }\n\n  try {\n    await signIn(\"credentials\", {\n      email,\n      password,\n      redirectTo: callbackUrl || DEFAULT_LOGIN_REDIRECT,\n    }); // explicitly setting the redirect (for clarity), even though middleware will redirect if user is logged in\n\n    return { success: \"Logged in!\" };\n  } catch (error) {\n    if (error instanceof AuthError) {\n      switch (error.type) {\n        case \"CredentialsSignin\": {\n          return { error: \"Invalid credentials!\" };\n        }\n        default: {\n          return { error: \"Something went wrong!\" };\n        }\n      }\n    }\n    throw error;\n  }\n};\n\nexport const logout = async () => {\n  await signOut();\n};\n\nexport const register = async (values: z.infer<typeof RegisterSchema>) => {\n  const validatedFields = RegisterSchema.safeParse(values);\n  if (!validatedFields.success) {\n    return { error: \"Invalid fields!\" };\n  }\n\n  const { email, password, name } = validatedFields.data;\n  const hashedPassword = await hashPassword(password);\n\n  const existingUser = await getUserByEmail(email);\n\n  if (existingUser) {\n    return { error: \"Email already in use!\" };\n  }\n\n  await db.user.create({\n    data: {\n      email,\n      password: hashedPassword,\n      name,\n    },\n  });\n\n  const verificationToken = await generateVerificationToken(email);\n  await sendVerificationEmail(verificationToken.email, verificationToken.token);\n\n  return { success: \"Confirmation Email Sent!\" };\n};\n\nexport const loginWithOAuth = async (\n  provider: string,\n  callbackUrl?: string | null,\n) => {\n  try {\n    await signIn(provider, {\n      redirectTo: callbackUrl || DEFAULT_LOGIN_REDIRECT,\n    });\n\n    return { success: \"Logged in!\" };\n  } catch (error) {\n    if (error === \"NEXT_REDIRECT\") {\n      // This is a redirect, not an actual error\n      return { success: \"Redirecting to OAuth provider...\" };\n    } else if (error instanceof AuthError) {\n      switch (error.type) {\n        case \"OAuthAccountNotLinked\":\n          return {\n            error: \"Email is already in use with a different provider.\",\n          };\n        default:\n          return { error: \"Something went wrong.\" };\n      }\n    }\n    throw error;\n  }\n};\n\nexport const newVerification = async (token: string) => {\n  const existingToken = await getVerificationTokenByToken(token);\n  if (!existingToken) {\n    return { error: \"Token does not exist\" };\n  }\n\n  const hasExpired = new Date(existingToken.expires) < new Date();\n\n  if (hasExpired) {\n    return { error: \"Token has expired\" };\n  }\n\n  const existingUser = await getUserByEmail(existingToken.email);\n\n  // Handle case where user exists - normal email verification for new registration\n  if (existingUser) {\n    await db.user.update({\n      where: { id: existingUser.id },\n      data: {\n        emailVerified: new Date(),\n      },\n    });\n  } else {\n    // If we can't find a user with this email, it might be from a registration\n    // that created the user but didn't set the email yet\n    const pendingUser = await db.user.findFirst({\n      where: {\n        OR: [{ email: null }, { emailVerified: null }],\n      },\n      orderBy: {\n        id: \"desc\",\n      },\n    });\n\n    if (!pendingUser) {\n      return { error: \"User not found!\" };\n    }\n\n    await db.user.update({\n      where: { id: pendingUser.id },\n      data: {\n        email: existingToken.email,\n        emailVerified: new Date(),\n      },\n    });\n  }\n\n  await db.verificationToken.delete({\n    where: { id: existingToken.id },\n  });\n\n  return { success: \"Email verified!\" };\n};\n\nexport const reset = async (values: z.infer<typeof ResetSchema>) => {\n  const validatedFields = ResetSchema.safeParse(values);\n\n  if (!validatedFields.success) return { error: \"Invalid email!\" };\n\n  const { email } = validatedFields.data;\n\n  const existingUser = await getUserByEmail(email);\n  if (!existingUser) return { error: \"Email not found!\" };\n\n  const isOAuthAccount = await db.account.findFirst({\n    where: { userId: existingUser?.id },\n  });\n\n  if (isOAuthAccount)\n    return { error: \"Cannot reset password for OAuth account!\" };\n\n  const passwordResetToken = await generatePasswordResetToken(email);\n  await sendPasswordResetEmail(\n    passwordResetToken.email,\n    passwordResetToken.token,\n  );\n\n  return { success: \"Reset password email sent\" };\n};\n\nexport const newPassword = async (\n  values: z.infer<typeof NewPasswordSchema>,\n  token?: string | null,\n) => {\n  if (!token) return { error: \"Missing token!\" };\n\n  const validatedFields = NewPasswordSchema.safeParse(values);\n\n  if (!validatedFields.success) return { error: \"Invalid fields!\" };\n\n  const { password } = validatedFields.data;\n\n  const existingToken = await getPasswordResetTokenByToken(token);\n\n  if (!existingToken) return { error: \"Invalid token!\" };\n\n  const hasExpired = new Date(existingToken.expires) < new Date();\n\n  if (hasExpired) return { error: \"Token has expired!\" };\n\n  const existingUser = await getUserByEmail(existingToken.email);\n\n  if (!existingUser) return { error: \"Email does not exist!\" };\n\n  const hashedPassword = await hashPassword(password);\n\n  await db.user.update({\n    where: { id: existingUser.id },\n    data: { password: hashedPassword },\n  });\n\n  await db.passwordResetToken.delete({\n    where: { id: existingToken.id },\n  });\n\n  return { success: \"Password updated!\" };\n};\n\n// New action for email change\nexport async function changeEmail(userId: string, newEmail: string) {\n  const existingUser = await db.user.findUnique({\n    where: { id: userId },\n  });\n\n  if (!existingUser) {\n    return { error: \"User not found!\" };\n  }\n\n  // Check if the new email is already used by another account\n  const emailTaken = await getUserByEmail(newEmail);\n  if (emailTaken && emailTaken.id !== userId) {\n    return { error: \"Email already in use by another account!\" };\n  }\n\n  // Store the user ID in the verification token\n  const verificationToken = await generateVerificationToken(newEmail, userId);\n\n  // Send verification email to the NEW email address with emailChange flag\n  await sendVerificationEmail(\n    newEmail,\n    verificationToken.token,\n    true, // Indicate this is an email change\n  );\n\n  // Update user record to indicate pending email change\n  await db.user.update({\n    where: { id: userId },\n    data: {\n      pendingEmail: newEmail,\n    },\n  });\n\n  return { success: \"Verification email sent to new address!\" };\n}\n\n// Action to verify email change\nexport async function verifyEmailChange(token: string) {\n  const existingToken = await getVerificationTokenByToken(token);\n\n  if (!existingToken) {\n    return { error: \"Token does not exist!\" };\n  }\n\n  const hasExpired = new Date(existingToken.expires) < new Date();\n\n  if (hasExpired) {\n    return { error: \"Token has expired!\" };\n  }\n\n  // Find the user who requested this email change using the userId stored in the token\n  if (!existingToken.userId) {\n    return { error: \"Invalid email change request!\" };\n  }\n\n  const user = await db.user.findUnique({\n    where: { id: existingToken.userId },\n  });\n\n  if (!user) {\n    return { error: \"User not found!\" };\n  }\n\n  // Update the user's email\n  await db.user.update({\n    where: { id: user.id },\n    data: {\n      email: existingToken.email,\n      emailVerified: new Date(),\n      pendingEmail: null, // Clear the pending email field\n    },\n  });\n\n  // Delete the verification token\n  await db.verificationToken.delete({\n    where: { id: existingToken.id },\n  });\n\n  return { success: \"Email updated successfully!\" };\n}\n\nexport const settings = async (\n  userId: string | { id: string } | any,\n  values: z.infer<typeof SettingsSchema>,\n) => {\n  const user = await currentUser();\n\n  if (!user) return { error: \"Unauthorized!\" };\n  // Handle different userId formats\n  const actualUserId =\n    typeof userId === \"string\"\n      ? userId\n      : typeof userId === \"object\" && userId?.id\n        ? userId.id\n        : null;\n\n  if (!actualUserId) {\n    return { error: \"Invalid user ID!\" };\n  }\n\n  const dbUser = await getUserById(user.id as string);\n\n  if (!dbUser) return { error: \"Unauthorized!\" };\n\n  // users who signed in with OAuth should not be able to modify these fields\n  if (user.isOAuth) {\n    values.email = undefined;\n    values.isTwoFactorEnabled = undefined;\n  }\n\n  // Handle email change if provided\n  if (values.email && values.email !== user.email) {\n    return await changeEmail(actualUserId, values.email);\n  }\n\n  // Handle name update\n  if (values.name !== undefined && values.name !== user.name) {\n    await db.user.update({\n      where: { id: actualUserId },\n      data: { name: values.name },\n    });\n  }\n\n  // Handle two-factor authentication toggle\n  if (\n    typeof values.isTwoFactorEnabled !== \"undefined\" &&\n    values.isTwoFactorEnabled !== dbUser.isTwoFactorEnabled\n  ) {\n    await db.user.update({\n      where: { id: actualUserId },\n      data: { isTwoFactorEnabled: values.isTwoFactorEnabled },\n    });\n  }\n\n  return { success: \"Profile updated!\" };\n};\n\n// Configure Cloudinary\ncloudinary.config({\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\n  api_key: process.env.CLOUDINARY_API_KEY,\n  api_secret: process.env.CLOUDINARY_API_SECRET,\n});\n\nexport async function updateUserImage(userId: string, imageData: string) {\n  try {\n    // Validate user ID\n    const user = await db.user.findUnique({\n      where: { id: userId },\n    });\n\n    if (!user) {\n      return { error: \"User not found!\" };\n    }\n\n    if (!imageData || !imageData.startsWith(\"data:image/\")) {\n      return { error: \"Invalid image data!\" };\n    }\n\n    // Upload to Cloudinary\n    const uploadResponse = await new Promise((resolve, reject) => {\n      cloudinary.uploader.upload(\n        imageData,\n        {\n          folder: \"user_profiles\",\n          // You can add transformation options here\n          // transformation: [{ width: 250, height: 250, crop: 'fill' }]\n        },\n        (error, result) => {\n          if (error) reject(error);\n          else resolve(result);\n        },\n      );\n    });\n\n    // Get the secure URL from the upload response\n    const imageUrl = (uploadResponse as { secure_url: string }).secure_url;\n\n    // Update the user's image URL in the database\n    await db.user.update({\n      where: { id: userId },\n      data: { image: imageUrl },\n    });\n\n    return { success: \"Profile picture updated!\" };\n  } catch (error) {\n    console.error(\"Error updating profile picture:\", error);\n    return { error: \"Failed to update profile picture.\" };\n  }\n}\n\nexport const changePassword = async (\n  currentPassword: string,\n  newPassword: string,\n) => {\n  const user = await currentUser();\n\n  if (!user) return { error: \"Unauthorized!\" };\n\n  // Block OAuth users from password changes\n  if (user.isOAuth) {\n    return { error: \"OAuth users cannot change password!\" };\n  }\n\n  const dbUser = await getUserById(user.id as string);\n\n  if (!dbUser) return { error: \"Unauthorized!\" };\n\n  const passwordsMatch = await verifyPassword(\n    currentPassword,\n    dbUser?.password!,\n  );\n\n  if (!passwordsMatch) {\n    return { error: \"Incorrect password!\" };\n  }\n\n  const hashedPassword = await hashPassword(newPassword);\n\n  await db.user.update({\n    where: { id: dbUser.id },\n    data: { password: hashedPassword },\n  });\n\n  return { success: \"Password updated!\" };\n};\n",
      "type": "registry:actions",
      "target": ""
    },
    {
      "path": "auth/lib/auth-helpers.ts",
      "content": "import { db } from \"@/registry/default/auth/lib/db\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport bcryptjs from \"bcryptjs\";\n\nexport const hashPassword = async (password: string) => {\n  return await bcryptjs.hash(password, 10);\n};\n\nexport const verifyPassword = async (\n  inputPassword: string,\n  hashedPassword: string,\n) => {\n  return await bcryptjs.compare(inputPassword, hashedPassword);\n};\n\nexport const getVerificationTokenByToken = async (token: string) => {\n  try {\n    const verificationToken = await db.verificationToken.findUnique({\n      where: { token },\n    });\n\n    return verificationToken;\n  } catch {\n    return null;\n  }\n};\n\nexport const getVerificationTokenByEmail = async (email: string) => {\n  try {\n    const verificationToken = await db.verificationToken.findFirst({\n      where: { email },\n    });\n\n    return verificationToken;\n  } catch {\n    return null;\n  }\n};\n\nexport const generateVerificationToken = async (\n  email: string,\n  userId?: string,\n) => {\n  const token = uuidv4();\n  const expires = new Date(new Date().getTime() + 3600 * 1000);\n\n  const existingToken = await getVerificationTokenByEmail(email);\n\n  if (existingToken) {\n    await db.verificationToken.delete({\n      where: { id: existingToken.id },\n    });\n  }\n\n  const verificationToken = await db.verificationToken.create({\n    data: {\n      email,\n      token,\n      expires,\n      userId, // Will be undefined for new registrations, populated for email changes\n    },\n  });\n\n  return verificationToken;\n};\n\nexport const getPasswordResetTokenByToken = async (token: string) => {\n  try {\n    const passwordResetToken = await db.passwordResetToken.findUnique({\n      where: {\n        token,\n      },\n    });\n    return passwordResetToken;\n  } catch {\n    return null;\n  }\n};\n\nexport const getPasswordResetTokenByEmail = async (email: string) => {\n  try {\n    const passwordResetToken = await db.passwordResetToken.findFirst({\n      where: {\n        email,\n      },\n    });\n    return passwordResetToken;\n  } catch {\n    return null;\n  }\n};\n\nexport const generatePasswordResetToken = async (email: string) => {\n  const token = uuidv4();\n  const expires = new Date(new Date().getTime() + 3600 * 1000);\n\n  const existingToken = await getPasswordResetTokenByEmail(email);\n\n  if (existingToken) {\n    await db.passwordResetToken.delete({\n      where: { id: existingToken.id },\n    });\n  }\n\n  const passwordResetToken = await db.passwordResetToken.create({\n    data: {\n      email,\n      token,\n      expires,\n    },\n  });\n\n  return passwordResetToken;\n};\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/user.ts",
      "content": "import { db } from \"@/registry/default/auth/lib/db\";\n\nexport const getUserByEmail = async (email: string) => {\n  try {\n    const user = await db.user.findFirst({\n      where: { email },\n    });\n    return user;\n  } catch (e) {\n    return null;\n  }\n};\nexport const getUpdatedEmailUser = async (email: string) => {\n  try {\n    const user = await db.verificationToken.findFirst({\n      where: { email },\n    });\n    return user;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getUserById = async (id: string) => {\n  try {\n    const user = await db.user.findFirst({\n      where: { id },\n    });\n    return user;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getAccountByUserId = async (userId: string) => {\n  try {\n    const account = await db.account.findFirst({\n      where: {\n        userId,\n      },\n    });\n\n    return account;\n  } catch {\n    return null;\n  }\n};\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/auth.ts",
      "content": "import NextAuth from \"next-auth\";\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\nimport authConfig from \"@/registry/default/auth/lib/auth.config\";\nimport { db } from \"@/registry/default/auth/lib/db\";\nimport {\n  getAccountByUserId,\n  getUserById,\n} from \"@/registry/default/auth/lib/user\";\nimport { getTwoFactorConfirmationByUserId } from \"@/registry/default/auth/actions/two-factor\";\n\nexport const { auth, handlers, signIn, signOut } = NextAuth({\n  pages: {\n    signIn: \"/auth/login\",\n    error: \"/auth/error\",\n  },\n  events: {\n    async linkAccount({ user }) {\n      await db.user.update({\n        where: { id: user.id },\n        data: { emailVerified: new Date() },\n      });\n    },\n  },\n  callbacks: {\n    async signIn({ user, account }) {\n      //Allow OAuth without email verification\n      if (account?.type !== \"credentials\") return true;\n      const existingUser = await getUserById(user.id!);\n\n      //Prevent login if email is not verified\n      if (!existingUser?.emailVerified) return false;\n\n      //2FA Check\n      if (existingUser.isTwoFactorEnabled) {\n        const twoFactorConfirmation = await getTwoFactorConfirmationByUserId(\n          existingUser.id,\n        );\n\n        if (!twoFactorConfirmation) return false;\n\n        // Delete two factor confirmation for next sign in\n        await db.twoFactorConfirmation.delete({\n          where: { id: twoFactorConfirmation.id },\n        });\n      }\n\n      return true;\n    },\n    async session({ session, token }) {\n      if (token.sub && session.user) {\n        session.user.id = token.sub;\n      }\n      if (token.role && session.user) {\n        session.user.role = token.role;\n      }\n\n      if (session.user) {\n        session.user.isTwoFactorEnabled = token.isTwoFactorEnabled;\n      }\n\n      // model fields that can be updated by the user in the settings page\n      if (session.user) {\n        session.user.name = token.name;\n        session.user.email = token.email as string;\n        session.user.isOAuth = token.isOAuth;\n        session.user.image = token.image as string;\n      }\n      return session;\n    },\n\n    async jwt({ token }) {\n      if (!token.sub) {\n        return token;\n      }\n\n      const existingUser = await getUserById(token.sub);\n\n      if (!existingUser) {\n        return token;\n      }\n      const existingAccount = await getAccountByUserId(existingUser.id);\n\n      token.role = existingUser.role;\n      token.isTwoFactorEnabled = existingUser.isTwoFactorEnabled;\n\n      // model fields that can be updated by the user in the settings page\n      token.name = existingUser.name;\n      token.email = existingUser.email;\n      token.image = existingUser.image;\n\n      // type conversion to boolean\n      token.isOAuth = !!existingAccount;\n\n      return token;\n    },\n  },\n  adapter: PrismaAdapter(db),\n  session: { strategy: \"jwt\" },\n  ...authConfig,\n});\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/next-auth.d.ts",
      "content": "import { UserRole } from \"@prisma/client\";\nimport NextAuth, { type DefaultSession } from \"next-auth\";\nimport { JWT } from \"next-auth/jwt\";\n\ndeclare module \"next-auth/jwt\" {\n  interface JWT {\n    role: UserRole;\n    isTwoFactorEnabled: boolean;\n    isOAuth: boolean;\n  }\n}\n\nexport type ExtendedUser = DefaultSession[\"user\"] & {\n  role: UserRole;\n  isTwoFactorEnabled: boolean;\n  isOAuth: boolean;\n};\n\ndeclare module \"next-auth\" {\n  interface Session {\n    user: ExtendedUser;\n  }\n}\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/routes.ts",
      "content": "export const publicRoutes = [\"/\", \"/auth/verify\"];\n\n/**\n * An array of routes that are accessible only to authenticated users.\n * @type {string[]}\n */\nexport const authRoutes = [\n  \"/auth/login\",\n  \"/auth/register\",\n  \"/auth/error\",\n  \"/auth/reset\",\n  \"/auth/new-password\",\n];\n\n/**\n * An array of routes that are accessible only to admin users.\n * @type {string[]}\n */\nexport const adminRoutes = [\n  \"/admin\",\n  // Add other admin routes here\n];\n\n/**\n * The prefix for all API auth routes.\n * @type {string}\n */\nexport const apiAuthPrefix = \"/api/auth\";\n\n/**\n * The default redirect path after a successful login.\n * @type {string}\n */\nexport const DEFAULT_LOGIN_REDIRECT = \"/dashboard\";\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/auth.config.ts",
      "content": "import Credentials from \"next-auth/providers/credentials\";\n\nimport { LoginSchema } from \"@/registry/default/auth/schemas\";\nimport GitHub from \"next-auth/providers/github\";\nimport type { NextAuthConfig } from \"next-auth\";\nimport Google from \"next-auth/providers/google\";\nimport { getUserByEmail } from \"@/registry/default/auth/lib/user\";\nimport { verifyPassword } from \"@/registry/default/auth/lib/auth-helpers\";\n\nexport default {\n  providers: [\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n    }),\n    GitHub({\n      clientId: process.env.GITHUB_CLIENT_ID,\n      clientSecret: process.env.GITHUB_CLIENT_SECRET,\n    }),\n    Credentials({\n      async authorize(credentials) {\n        const validatedFields = LoginSchema.safeParse(credentials);\n\n        if (validatedFields.success) {\n          const { email, password } = validatedFields.data;\n          const user = await getUserByEmail(email);\n\n          if (!user || !user.password) return null;\n\n          const passwordsMatch = await verifyPassword(password, user.password);\n\n          if (passwordsMatch) return user;\n        }\n        return null;\n      },\n    }),\n  ],\n} satisfies NextAuthConfig;\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}