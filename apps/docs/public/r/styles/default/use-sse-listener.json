{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "use-sse-listener",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-sse-listener.tsx",
      "content": "import { useEffect, useState, useRef, useCallback } from \"react\";\r\n\r\ninterface SseOptions {\r\n  /** URL for the SSE endpoint */\r\n  url: string;\r\n  /** Whether to connect immediately (default: true) */\r\n  autoConnect?: boolean;\r\n  /** Custom headers for the EventSource connection */\r\n  headers?: Record<string, string>;\r\n  /** Reconnect timeout in milliseconds (default: 5000) */\r\n  reconnectTimeout?: number;\r\n  /** Map of event types to listen for (in addition to 'message') */\r\n  events?: string[];\r\n  /** Whether to use withCredentials (default: false) */\r\n  withCredentials?: boolean;\r\n  /** Optional retry limit, after which reconnection attempts will stop */\r\n  maxRetries?: number;\r\n}\r\n\r\ntype SseStatus = \"IDLE\" | \"CONNECTING\" | \"OPEN\" | \"CLOSED\" | \"ERROR\";\r\n\r\ninterface SseEvent {\r\n  type: string;\r\n  data: any;\r\n  id?: string;\r\n  retry?: number;\r\n  lastEventId?: string;\r\n  timestamp: number;\r\n}\r\n\r\n/**\r\n * Custom hook for Server-Sent Events (SSE) with reconnection logic\r\n *\r\n * @param options Configuration options for the SSE connection\r\n * @returns Object containing connection status and control functions\r\n */\r\nexport function useSseListener(options: SseOptions) {\r\n  const {\r\n    url,\r\n    autoConnect = true,\r\n    headers = {},\r\n    reconnectTimeout = 5000,\r\n    events = [],\r\n    withCredentials = false,\r\n    maxRetries,\r\n  } = options;\r\n\r\n  const [status, setStatus] = useState<SseStatus>(\"IDLE\");\r\n  const [events$, setEvents] = useState<SseEvent[]>([]);\r\n  const [lastEvent, setLastEvent] = useState<SseEvent | null>(null);\r\n  const [error, setError] = useState<Error | null>(null);\r\n  const [retryCount, setRetryCount] = useState(0);\r\n\r\n  const eventSourceRef = useRef<EventSource | null>(null);\r\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n\r\n  const cleanup = useCallback(() => {\r\n    if (eventSourceRef.current) {\r\n      eventSourceRef.current.close();\r\n      eventSourceRef.current = null;\r\n    }\r\n\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n      timeoutRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const connect = useCallback(() => {\r\n    cleanup();\r\n\r\n    if (maxRetries !== undefined && retryCount >= maxRetries) {\r\n      setStatus(\"CLOSED\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      setStatus(\"CONNECTING\");\r\n\r\n      // For custom headers, we need to use a proxy server or polyfill\r\n      // since native EventSource doesn't support custom headers\r\n      if (Object.keys(headers).length > 0) {\r\n        // This implementation assumes you're using a proxy server or middleware\r\n        // that handles the headers, or you're using a polyfill like 'event-source-polyfill'\r\n        const queryParams = new URLSearchParams();\r\n\r\n        // Add headers as query parameters for the proxy to handle\r\n        Object.entries(headers).forEach(([key, value]) => {\r\n          queryParams.append(`header-${key}`, value);\r\n        });\r\n\r\n        const urlWithHeaders = `${url}${url.includes(\"?\") ? \"&\" : \"?\"}${queryParams.toString()}`;\r\n        eventSourceRef.current = new EventSource(urlWithHeaders, {\r\n          withCredentials,\r\n        });\r\n      } else {\r\n        eventSourceRef.current = new EventSource(url, { withCredentials });\r\n      }\r\n\r\n      // Handle connection opening\r\n      eventSourceRef.current.onopen = () => {\r\n        setStatus(\"OPEN\");\r\n        setError(null);\r\n        setRetryCount(0); // Reset retry count on successful connection\r\n      };\r\n\r\n      // Handle generic messages\r\n      eventSourceRef.current.onmessage = (event) => {\r\n        try {\r\n          const parsedData = JSON.parse(event.data);\r\n          const newEvent: SseEvent = {\r\n            type: \"message\",\r\n            data: parsedData,\r\n            id: event.lastEventId,\r\n            lastEventId: event.lastEventId,\r\n            timestamp: Date.now(),\r\n          };\r\n\r\n          setEvents((prev) => [...prev, newEvent]);\r\n          setLastEvent(newEvent);\r\n        } catch (e) {\r\n          // Handle non-JSON data\r\n          const newEvent: SseEvent = {\r\n            type: \"message\",\r\n            data: event.data,\r\n            id: event.lastEventId,\r\n            lastEventId: event.lastEventId,\r\n            timestamp: Date.now(),\r\n          };\r\n\r\n          setEvents((prev) => [...prev, newEvent]);\r\n          setLastEvent(newEvent);\r\n        }\r\n      };\r\n\r\n      // Add listeners for custom events\r\n      events.forEach((eventType) => {\r\n        eventSourceRef.current?.addEventListener(eventType, (event) => {\r\n          try {\r\n            const parsedData = JSON.parse(event.data);\r\n            const newEvent: SseEvent = {\r\n              type: eventType,\r\n              data: parsedData,\r\n              id: event.lastEventId,\r\n              lastEventId: event.lastEventId,\r\n              timestamp: Date.now(),\r\n            };\r\n\r\n            setEvents((prev) => [...prev, newEvent]);\r\n            setLastEvent(newEvent);\r\n          } catch (e) {\r\n            // Handle non-JSON data\r\n            const newEvent: SseEvent = {\r\n              type: eventType,\r\n              data: event.data,\r\n              id: event.lastEventId,\r\n              lastEventId: event.lastEventId,\r\n              timestamp: Date.now(),\r\n            };\r\n\r\n            setEvents((prev) => [...prev, newEvent]);\r\n            setLastEvent(newEvent);\r\n          }\r\n        });\r\n      });\r\n\r\n      // Handle errors\r\n      eventSourceRef.current.onerror = (e) => {\r\n        setStatus(\"ERROR\");\r\n        setError(new Error(\"SSE connection error\"));\r\n\r\n        // Attempt to reconnect\r\n        cleanup();\r\n        setRetryCount((prev) => prev + 1);\r\n\r\n        timeoutRef.current = setTimeout(() => {\r\n          connect();\r\n        }, reconnectTimeout);\r\n      };\r\n    } catch (e) {\r\n      setStatus(\"ERROR\");\r\n      setError(e instanceof Error ? e : new Error(\"Unknown SSE error\"));\r\n\r\n      // Attempt to reconnect\r\n      cleanup();\r\n      setRetryCount((prev) => prev + 1);\r\n\r\n      timeoutRef.current = setTimeout(() => {\r\n        connect();\r\n      }, reconnectTimeout);\r\n    }\r\n  }, [\r\n    url,\r\n    headers,\r\n    cleanup,\r\n    events,\r\n    reconnectTimeout,\r\n    withCredentials,\r\n    retryCount,\r\n    maxRetries,\r\n  ]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    cleanup();\r\n    setStatus(\"CLOSED\");\r\n  }, [cleanup]);\r\n\r\n  // Connect automatically if autoConnect is true\r\n  useEffect(() => {\r\n    if (autoConnect) {\r\n      connect();\r\n    }\r\n\r\n    return () => {\r\n      cleanup();\r\n    };\r\n  }, [autoConnect, connect, cleanup]);\r\n\r\n  return {\r\n    status,\r\n    events: events$,\r\n    lastEvent,\r\n    error,\r\n    connect,\r\n    disconnect,\r\n    retryCount,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}