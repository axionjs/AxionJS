{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "use-web-socket",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-web-socket.tsx",
      "content": "import { useEffect, useRef, useState, useCallback } from \"react\";\n\ninterface WebSocketOptions {\n  /** WebSocket URL to connect to */\n  url: string;\n  /** Protocols string or array of protocol strings */\n  protocols?: string | string[];\n  /** Whether to auto-connect on mount (default: true) */\n  autoConnect?: boolean;\n  /** Whether to auto-reconnect on close/error (default: true) */\n  autoReconnect?: boolean;\n  /** Retry backoff in milliseconds (default: 1000) */\n  reconnectInterval?: number;\n  /** Maximum reconnect attempts (default: Infinity) */\n  maxReconnectAttempt?: number;\n  /** Maximum reconnect interval with exponential backoff (default: 30000) */\n  maxReconnectInterval?: number;\n  /** Whether to use exponential backoff for reconnect (default: true) */\n  exponentialBackoff?: boolean;\n  /** Callback when connection opens */\n  onOpen?: (event: WebSocketEventMap[\"open\"]) => void;\n  /** Callback when connection closes */\n  onClose?: (event: WebSocketEventMap[\"close\"]) => void;\n  /** Callback when connection errors */\n  onError?: (event: WebSocketEventMap[\"error\"]) => void;\n  /** Callback when message is received */\n  onMessage?: (event: WebSocketEventMap[\"message\"]) => void;\n  /** WebSocket BinaryType (\"blob\" | \"arraybuffer\") */\n  binaryType?: BinaryType;\n  /** Handle automatic JSON parsing/stringifying (default: false) */\n  jsonMode?: boolean;\n}\n\ntype ReadyState = number;\n\ninterface WebSocketMessage {\n  data: any;\n  timestamp: number;\n  type: string;\n}\n\nconst ReadyStateStatus = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3,\n} as const;\n\n/**\n * Custom hook for managing WebSocket connections with reconnection logic\n *\n * @param options Configuration options for the WebSocket connection\n * @returns Object containing WebSocket state and control functions\n */\nexport function useWebSocket(options: WebSocketOptions) {\n  const {\n    url,\n    protocols,\n    autoConnect = true,\n    autoReconnect = true,\n    reconnectInterval = 1000,\n    maxReconnectAttempt = Infinity,\n    maxReconnectInterval = 30000,\n    exponentialBackoff = true,\n    onOpen,\n    onClose,\n    onError,\n    onMessage,\n    binaryType = \"blob\",\n    jsonMode = false,\n  } = options;\n\n  const socket = useRef<WebSocket | null>(null);\n  const reconnectCount = useRef<number>(0);\n  const reconnectTimeoutId = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isMountedRef = useRef<boolean>(true);\n\n  const [readyState, setReadyState] = useState<ReadyState>(\n    ReadyStateStatus.CLOSED,\n  );\n  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);\n  const [messages, setMessages] = useState<WebSocketMessage[]>([]);\n  const [error, setError] = useState<Event | null>(null);\n\n  // Event handler refs to avoid dependency changes\n  const onOpenRef = useRef(onOpen);\n  const onCloseRef = useRef(onClose);\n  const onErrorRef = useRef(onError);\n  const onMessageRef = useRef(onMessage);\n\n  // Update callback refs when they change\n  useEffect(() => {\n    onOpenRef.current = onOpen;\n    onCloseRef.current = onClose;\n    onErrorRef.current = onError;\n    onMessageRef.current = onMessage;\n  }, [onOpen, onClose, onError, onMessage]);\n\n  // Function to calculate the reconnect delay with exponential backoff\n  const getReconnectDelay = useCallback(() => {\n    if (!exponentialBackoff) {\n      return reconnectInterval;\n    }\n\n    // Calculate exponential backoff: min(reconnectInterval * 2 ^ reconnectCount, maxReconnectInterval)\n    const delay = reconnectInterval * Math.pow(2, reconnectCount.current);\n    return Math.min(delay, maxReconnectInterval);\n  }, [reconnectInterval, maxReconnectInterval, exponentialBackoff]);\n\n  // Connect to WebSocket\n  const connect = useCallback(() => {\n    if (!isMountedRef.current) return;\n\n    // Clear any existing reconnect timeout\n    if (reconnectTimeoutId.current !== null) {\n      clearTimeout(reconnectTimeoutId.current);\n      reconnectTimeoutId.current = null;\n    }\n\n    // Close existing socket if it exists\n    if (socket.current) {\n      socket.current.close();\n    }\n\n    try {\n      // Create new WebSocket connection\n      socket.current = new WebSocket(url, protocols);\n\n      // Set binary type (blob or arraybuffer)\n      socket.current.binaryType = binaryType;\n\n      // Set initial ready state\n      setReadyState(ReadyStateStatus.CONNECTING);\n\n      // Event handlers\n      socket.current.onopen = (event) => {\n        if (!isMountedRef.current) return;\n\n        setReadyState(ReadyStateStatus.OPEN);\n        setError(null);\n        reconnectCount.current = 0;\n\n        if (onOpenRef.current) {\n          onOpenRef.current(event);\n        }\n      };\n\n      socket.current.onclose = (event) => {\n        if (!isMountedRef.current) return;\n\n        setReadyState(ReadyStateStatus.CLOSED);\n\n        if (onCloseRef.current) {\n          onCloseRef.current(event);\n        }\n\n        // Handle reconnection\n        if (autoReconnect && reconnectCount.current < maxReconnectAttempt) {\n          const delay = getReconnectDelay();\n          reconnectCount.current += 1;\n\n          reconnectTimeoutId.current = setTimeout(() => {\n            if (isMountedRef.current) {\n              connect();\n            }\n          }, delay);\n        }\n      };\n\n      socket.current.onerror = (event) => {\n        if (!isMountedRef.current) return;\n\n        setError(event);\n\n        if (onErrorRef.current) {\n          onErrorRef.current(event);\n        }\n      };\n\n      socket.current.onmessage = (event) => {\n        if (!isMountedRef.current) return;\n\n        let parsedData: any = event.data;\n        let messageType = typeof event.data;\n\n        // Handle JSON parsing if jsonMode is enabled\n        if (jsonMode && typeof event.data === \"string\") {\n          try {\n            parsedData = JSON.parse(event.data);\n            messageType = \"json\";\n          } catch (err) {\n            // If parsing fails, keep the original data\n            messageType = \"text\";\n          }\n        }\n\n        const message: WebSocketMessage = {\n          data: parsedData,\n          timestamp: Date.now(),\n          type: messageType,\n        };\n\n        setLastMessage(message);\n        setMessages((prev) => [...prev, message]);\n\n        if (onMessageRef.current) {\n          onMessageRef.current(event);\n        }\n      };\n    } catch (err) {\n      console.error(\"WebSocket connection error:\", err);\n      setError(new ErrorEvent(\"error\", { error: err }));\n\n      // Handle reconnection on connection error\n      if (autoReconnect && reconnectCount.current < maxReconnectAttempt) {\n        const delay = getReconnectDelay();\n        reconnectCount.current += 1;\n\n        reconnectTimeoutId.current = setTimeout(() => {\n          if (isMountedRef.current) {\n            connect();\n          }\n        }, delay);\n      }\n    }\n  }, [\n    url,\n    protocols,\n    binaryType,\n    autoReconnect,\n    maxReconnectAttempt,\n    getReconnectDelay,\n    jsonMode,\n  ]);\n\n  // Disconnect from WebSocket\n  const disconnect = useCallback(() => {\n    if (socket.current && socket.current.readyState === ReadyStateStatus.OPEN) {\n      socket.current.close();\n    }\n\n    if (reconnectTimeoutId.current !== null) {\n      clearTimeout(reconnectTimeoutId.current);\n      reconnectTimeoutId.current = null;\n    }\n  }, []);\n\n  // Send message through WebSocket\n  const send = useCallback(\n    (data: string | ArrayBufferLike | Blob | ArrayBufferView) => {\n      if (\n        !socket.current ||\n        socket.current.readyState !== ReadyStateStatus.OPEN\n      ) {\n        throw new Error(\"WebSocket is not connected\");\n      }\n\n      // Handle JSON stringifying if jsonMode is enabled and data is not already a string\n      if (\n        jsonMode &&\n        typeof data !== \"string\" &&\n        !(data instanceof Blob) &&\n        !(data instanceof ArrayBuffer)\n      ) {\n        try {\n          socket.current.send(JSON.stringify(data));\n        } catch (err) {\n          throw new Error(\"Failed to stringify data to JSON\");\n        }\n        return;\n      }\n\n      socket.current.send(data);\n    },\n    [jsonMode],\n  );\n\n  // Connect on mount if autoConnect is true\n  useEffect(() => {\n    isMountedRef.current = true;\n\n    if (autoConnect) {\n      connect();\n    }\n\n    return () => {\n      isMountedRef.current = false;\n      disconnect();\n    };\n  }, [connect, disconnect, autoConnect]);\n\n  // Reconnect if URL changes\n  useEffect(() => {\n    if (socket.current) {\n      disconnect();\n      connect();\n    }\n  }, [url, protocols, connect, disconnect]);\n\n  return {\n    readyState,\n    isConnecting: readyState === ReadyStateStatus.CONNECTING,\n    isOpen: readyState === ReadyStateStatus.OPEN,\n    isClosing: readyState === ReadyStateStatus.CLOSING,\n    isClosed: readyState === ReadyStateStatus.CLOSED,\n    lastMessage,\n    messages,\n    error,\n    connect,\n    disconnect,\n    send,\n    socket: socket.current,\n    READY_STATE: ReadyStateStatus,\n  };\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}