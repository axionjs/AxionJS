{
  "$schema": "https://www.axionjs.com/schema/registry-item.json",
  "name": "use-web-socket",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-web-socket.tsx",
      "content": "import { useEffect, useRef, useState, useCallback } from \"react\";\r\n\r\ninterface WebSocketOptions {\r\n  /** WebSocket URL to connect to */\r\n  url: string;\r\n  /** Protocols string or array of protocol strings */\r\n  protocols?: string | string[];\r\n  /** Whether to auto-connect on mount (default: true) */\r\n  autoConnect?: boolean;\r\n  /** Whether to auto-reconnect on close/error (default: true) */\r\n  autoReconnect?: boolean;\r\n  /** Retry backoff in milliseconds (default: 1000) */\r\n  reconnectInterval?: number;\r\n  /** Maximum reconnect attempts (default: Infinity) */\r\n  maxReconnectAttempt?: number;\r\n  /** Maximum reconnect interval with exponential backoff (default: 30000) */\r\n  maxReconnectInterval?: number;\r\n  /** Whether to use exponential backoff for reconnect (default: true) */\r\n  exponentialBackoff?: boolean;\r\n  /** Callback when connection opens */\r\n  onOpen?: (event: WebSocketEventMap[\"open\"]) => void;\r\n  /** Callback when connection closes */\r\n  onClose?: (event: WebSocketEventMap[\"close\"]) => void;\r\n  /** Callback when connection errors */\r\n  onError?: (event: WebSocketEventMap[\"error\"]) => void;\r\n  /** Callback when message is received */\r\n  onMessage?: (event: WebSocketEventMap[\"message\"]) => void;\r\n  /** WebSocket BinaryType (\"blob\" | \"arraybuffer\") */\r\n  binaryType?: BinaryType;\r\n  /** Handle automatic JSON parsing/stringifying (default: false) */\r\n  jsonMode?: boolean;\r\n}\r\n\r\ntype ReadyState = number;\r\n\r\ninterface WebSocketMessage {\r\n  data: any;\r\n  timestamp: number;\r\n  type: string;\r\n}\r\n\r\nconst ReadyStateStatus = {\r\n  CONNECTING: 0,\r\n  OPEN: 1,\r\n  CLOSING: 2,\r\n  CLOSED: 3,\r\n} as const;\r\n\r\n/**\r\n * Custom hook for managing WebSocket connections with reconnection logic\r\n *\r\n * @param options Configuration options for the WebSocket connection\r\n * @returns Object containing WebSocket state and control functions\r\n */\r\nexport function useWebSocket(options: WebSocketOptions) {\r\n  const {\r\n    url,\r\n    protocols,\r\n    autoConnect = true,\r\n    autoReconnect = true,\r\n    reconnectInterval = 1000,\r\n    maxReconnectAttempt = Infinity,\r\n    maxReconnectInterval = 30000,\r\n    exponentialBackoff = true,\r\n    onOpen,\r\n    onClose,\r\n    onError,\r\n    onMessage,\r\n    binaryType = \"blob\",\r\n    jsonMode = false,\r\n  } = options;\r\n\r\n  const socket = useRef<WebSocket | null>(null);\r\n  const reconnectCount = useRef<number>(0);\r\n  const reconnectTimeoutId = useRef<ReturnType<typeof setTimeout> | null>(null);\r\n  const isMountedRef = useRef<boolean>(true);\r\n\r\n  const [readyState, setReadyState] = useState<ReadyState>(\r\n    ReadyStateStatus.CLOSED,\r\n  );\r\n  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);\r\n  const [messages, setMessages] = useState<WebSocketMessage[]>([]);\r\n  const [error, setError] = useState<Event | null>(null);\r\n\r\n  // Event handler refs to avoid dependency changes\r\n  const onOpenRef = useRef(onOpen);\r\n  const onCloseRef = useRef(onClose);\r\n  const onErrorRef = useRef(onError);\r\n  const onMessageRef = useRef(onMessage);\r\n\r\n  // Update callback refs when they change\r\n  useEffect(() => {\r\n    onOpenRef.current = onOpen;\r\n    onCloseRef.current = onClose;\r\n    onErrorRef.current = onError;\r\n    onMessageRef.current = onMessage;\r\n  }, [onOpen, onClose, onError, onMessage]);\r\n\r\n  // Function to calculate the reconnect delay with exponential backoff\r\n  const getReconnectDelay = useCallback(() => {\r\n    if (!exponentialBackoff) {\r\n      return reconnectInterval;\r\n    }\r\n\r\n    // Calculate exponential backoff: min(reconnectInterval * 2 ^ reconnectCount, maxReconnectInterval)\r\n    const delay = reconnectInterval * Math.pow(2, reconnectCount.current);\r\n    return Math.min(delay, maxReconnectInterval);\r\n  }, [reconnectInterval, maxReconnectInterval, exponentialBackoff]);\r\n\r\n  // Connect to WebSocket\r\n  const connect = useCallback(() => {\r\n    if (!isMountedRef.current) return;\r\n\r\n    // Clear any existing reconnect timeout\r\n    if (reconnectTimeoutId.current !== null) {\r\n      clearTimeout(reconnectTimeoutId.current);\r\n      reconnectTimeoutId.current = null;\r\n    }\r\n\r\n    // Close existing socket if it exists\r\n    if (socket.current) {\r\n      socket.current.close();\r\n    }\r\n\r\n    try {\r\n      // Create new WebSocket connection\r\n      socket.current = new WebSocket(url, protocols);\r\n\r\n      // Set binary type (blob or arraybuffer)\r\n      socket.current.binaryType = binaryType;\r\n\r\n      // Set initial ready state\r\n      setReadyState(ReadyStateStatus.CONNECTING);\r\n\r\n      // Event handlers\r\n      socket.current.onopen = (event) => {\r\n        if (!isMountedRef.current) return;\r\n\r\n        setReadyState(ReadyStateStatus.OPEN);\r\n        setError(null);\r\n        reconnectCount.current = 0;\r\n\r\n        if (onOpenRef.current) {\r\n          onOpenRef.current(event);\r\n        }\r\n      };\r\n\r\n      socket.current.onclose = (event) => {\r\n        if (!isMountedRef.current) return;\r\n\r\n        setReadyState(ReadyStateStatus.CLOSED);\r\n\r\n        if (onCloseRef.current) {\r\n          onCloseRef.current(event);\r\n        }\r\n\r\n        // Handle reconnection\r\n        if (autoReconnect && reconnectCount.current < maxReconnectAttempt) {\r\n          const delay = getReconnectDelay();\r\n          reconnectCount.current += 1;\r\n\r\n          reconnectTimeoutId.current = setTimeout(() => {\r\n            if (isMountedRef.current) {\r\n              connect();\r\n            }\r\n          }, delay);\r\n        }\r\n      };\r\n\r\n      socket.current.onerror = (event) => {\r\n        if (!isMountedRef.current) return;\r\n\r\n        setError(event);\r\n\r\n        if (onErrorRef.current) {\r\n          onErrorRef.current(event);\r\n        }\r\n      };\r\n\r\n      socket.current.onmessage = (event) => {\r\n        if (!isMountedRef.current) return;\r\n\r\n        let parsedData: any = event.data;\r\n        let messageType = typeof event.data;\r\n\r\n        // Handle JSON parsing if jsonMode is enabled\r\n        if (jsonMode && typeof event.data === \"string\") {\r\n          try {\r\n            parsedData = JSON.parse(event.data);\r\n            messageType = \"json\";\r\n          } catch (err) {\r\n            // If parsing fails, keep the original data\r\n            messageType = \"text\";\r\n          }\r\n        }\r\n\r\n        const message: WebSocketMessage = {\r\n          data: parsedData,\r\n          timestamp: Date.now(),\r\n          type: messageType,\r\n        };\r\n\r\n        setLastMessage(message);\r\n        setMessages((prev) => [...prev, message]);\r\n\r\n        if (onMessageRef.current) {\r\n          onMessageRef.current(event);\r\n        }\r\n      };\r\n    } catch (err) {\r\n      console.error(\"WebSocket connection error:\", err);\r\n      setError(new ErrorEvent(\"error\", { error: err }));\r\n\r\n      // Handle reconnection on connection error\r\n      if (autoReconnect && reconnectCount.current < maxReconnectAttempt) {\r\n        const delay = getReconnectDelay();\r\n        reconnectCount.current += 1;\r\n\r\n        reconnectTimeoutId.current = setTimeout(() => {\r\n          if (isMountedRef.current) {\r\n            connect();\r\n          }\r\n        }, delay);\r\n      }\r\n    }\r\n  }, [\r\n    url,\r\n    protocols,\r\n    binaryType,\r\n    autoReconnect,\r\n    maxReconnectAttempt,\r\n    getReconnectDelay,\r\n    jsonMode,\r\n  ]);\r\n\r\n  // Disconnect from WebSocket\r\n  const disconnect = useCallback(() => {\r\n    if (socket.current && socket.current.readyState === ReadyStateStatus.OPEN) {\r\n      socket.current.close();\r\n    }\r\n\r\n    if (reconnectTimeoutId.current !== null) {\r\n      clearTimeout(reconnectTimeoutId.current);\r\n      reconnectTimeoutId.current = null;\r\n    }\r\n  }, []);\r\n\r\n  // Send message through WebSocket\r\n  const send = useCallback(\r\n    (data: string | ArrayBufferLike | Blob | ArrayBufferView) => {\r\n      if (\r\n        !socket.current ||\r\n        socket.current.readyState !== ReadyStateStatus.OPEN\r\n      ) {\r\n        throw new Error(\"WebSocket is not connected\");\r\n      }\r\n\r\n      // Handle JSON stringifying if jsonMode is enabled and data is not already a string\r\n      if (\r\n        jsonMode &&\r\n        typeof data !== \"string\" &&\r\n        !(data instanceof Blob) &&\r\n        !(data instanceof ArrayBuffer)\r\n      ) {\r\n        try {\r\n          socket.current.send(JSON.stringify(data));\r\n        } catch (err) {\r\n          throw new Error(\"Failed to stringify data to JSON\");\r\n        }\r\n        return;\r\n      }\r\n\r\n      socket.current.send(data);\r\n    },\r\n    [jsonMode],\r\n  );\r\n\r\n  // Connect on mount if autoConnect is true\r\n  useEffect(() => {\r\n    isMountedRef.current = true;\r\n\r\n    if (autoConnect) {\r\n      connect();\r\n    }\r\n\r\n    return () => {\r\n      isMountedRef.current = false;\r\n      disconnect();\r\n    };\r\n  }, [connect, disconnect, autoConnect]);\r\n\r\n  // Reconnect if URL changes\r\n  useEffect(() => {\r\n    if (socket.current) {\r\n      disconnect();\r\n      connect();\r\n    }\r\n  }, [url, protocols, connect, disconnect]);\r\n\r\n  return {\r\n    readyState,\r\n    isConnecting: readyState === ReadyStateStatus.CONNECTING,\r\n    isOpen: readyState === ReadyStateStatus.OPEN,\r\n    isClosing: readyState === ReadyStateStatus.CLOSING,\r\n    isClosed: readyState === ReadyStateStatus.CLOSED,\r\n    lastMessage,\r\n    messages,\r\n    error,\r\n    connect,\r\n    disconnect,\r\n    send,\r\n    socket: socket.current,\r\n    READY_STATE: ReadyStateStatus,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}