{
  "$schema": "https://www.axionjs.com/schema/registry-item.json",
  "name": "use-form",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-form.tsx",
      "content": "\"use client\";\r\n\r\nimport * as React from \"react\";\r\n\r\ntype FormState<T> = {\r\n  values: T;\r\n  errors: Partial<Record<keyof T, string>>;\r\n  touched: Partial<Record<keyof T, boolean>>;\r\n  isSubmitting: boolean;\r\n  isValid: boolean;\r\n};\r\n\r\ntype FormActions<T> = {\r\n  setFieldValue: (field: keyof T, value: any) => void;\r\n  setFieldError: (field: keyof T, error: string) => void;\r\n  setFieldTouched: (field: keyof T, isTouched: boolean) => void;\r\n  setValues: (values: Partial<T>) => void;\r\n  setErrors: (errors: Partial<Record<keyof T, string>>) => void;\r\n  resetForm: () => void;\r\n  submitForm: () => Promise<void>;\r\n};\r\n\r\ninterface UseFormProps<T> {\r\n  initialValues: T;\r\n  validate?: (values: T) => Partial<Record<keyof T, string>>;\r\n  onSubmit: (values: T) => Promise<void> | void;\r\n}\r\n\r\n/**\r\n * A hook for managing form state and validation\r\n * @param props The form configuration\r\n * @returns Form state and actions\r\n */\r\nexport function useForm<T extends Record<string, any>>({\r\n  initialValues,\r\n  validate,\r\n  onSubmit,\r\n}: UseFormProps<T>): [FormState<T>, FormActions<T>] {\r\n  const [state, setState] = React.useState<FormState<T>>({\r\n    values: initialValues,\r\n    errors: {},\r\n    touched: {},\r\n    isSubmitting: false,\r\n    isValid: true,\r\n  });\r\n\r\n  const validateForm = React.useCallback(() => {\r\n    if (!validate) return {};\r\n\r\n    const errors = validate(state.values);\r\n    return errors;\r\n  }, [validate, state.values]);\r\n\r\n  // Update isValid when values change\r\n  React.useEffect(() => {\r\n    if (!validate) return;\r\n\r\n    const errors = validate(state.values);\r\n    const isValid = Object.keys(errors).length === 0;\r\n\r\n    // Only update state if errors or validity changed\r\n    if (\r\n      JSON.stringify(errors) !== JSON.stringify(state.errors) ||\r\n      isValid !== state.isValid\r\n    ) {\r\n      setState((prev) => ({ ...prev, errors, isValid }));\r\n    }\r\n  }, [validate, state.values]);\r\n\r\n  const setFieldValue = React.useCallback((field: keyof T, value: any) => {\r\n    setState((prev) => ({\r\n      ...prev,\r\n      values: { ...prev.values, [field]: value },\r\n      touched: { ...prev.touched, [field]: true },\r\n    }));\r\n  }, []);\r\n\r\n  const setFieldError = React.useCallback((field: keyof T, error: string) => {\r\n    setState((prev) => ({\r\n      ...prev,\r\n      errors: { ...prev.errors, [field]: error },\r\n    }));\r\n  }, []);\r\n\r\n  const setFieldTouched = React.useCallback(\r\n    (field: keyof T, isTouched: boolean) => {\r\n      setState((prev) => ({\r\n        ...prev,\r\n        touched: { ...prev.touched, [field]: isTouched },\r\n      }));\r\n    },\r\n    [],\r\n  );\r\n\r\n  const setValues = React.useCallback((values: Partial<T>) => {\r\n    setState((prev) => ({\r\n      ...prev,\r\n      values: { ...prev.values, ...values },\r\n    }));\r\n  }, []);\r\n\r\n  const setErrors = React.useCallback(\r\n    (errors: Partial<Record<keyof T, string>>) => {\r\n      setState((prev) => ({\r\n        ...prev,\r\n        errors: { ...prev.errors, ...errors },\r\n      }));\r\n    },\r\n    [],\r\n  );\r\n\r\n  const resetForm = React.useCallback(() => {\r\n    setState({\r\n      values: initialValues,\r\n      errors: {},\r\n      touched: {},\r\n      isSubmitting: false,\r\n      isValid: true,\r\n    });\r\n  }, [initialValues]);\r\n\r\n  const submitForm = React.useCallback(async () => {\r\n    if (!validate) {\r\n      setState((prev) => ({ ...prev, isSubmitting: true }));\r\n\r\n      try {\r\n        await onSubmit(state.values);\r\n      } finally {\r\n        setState((prev) => ({ ...prev, isSubmitting: false }));\r\n      }\r\n      return;\r\n    }\r\n\r\n    const errors = validate(state.values);\r\n\r\n    if (Object.keys(errors).length === 0) {\r\n      setState((prev) => ({ ...prev, isSubmitting: true }));\r\n\r\n      try {\r\n        await onSubmit(state.values);\r\n      } finally {\r\n        setState((prev) => ({ ...prev, isSubmitting: false }));\r\n      }\r\n    } else {\r\n      setState((prev) => ({\r\n        ...prev,\r\n        errors,\r\n        isValid: false,\r\n      }));\r\n    }\r\n  }, [onSubmit, state.values, validate]);\r\n\r\n  const actions: FormActions<T> = {\r\n    setFieldValue,\r\n    setFieldError,\r\n    setFieldTouched,\r\n    setValues,\r\n    setErrors,\r\n    resetForm,\r\n    submitForm,\r\n  };\r\n\r\n  return [state, actions];\r\n}\r\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}