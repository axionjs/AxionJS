{
  "$schema": "https://www.axionjs.com/schema/registry-item.json",
  "name": "use-undo-redo",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-undo-redo.tsx",
      "content": "import { useCallback, useReducer } from \"react\";\r\n\r\ninterface HistoryState<T> {\r\n  past: T[];\r\n  present: T;\r\n  future: T[];\r\n}\r\n\r\ntype HistoryAction<T> =\r\n  | { type: \"UNDO\" }\r\n  | { type: \"REDO\" }\r\n  | { type: \"SET\"; newPresent: T }\r\n  | { type: \"CLEAR\"; initialPresent: T };\r\n\r\n/**\r\n * A hook that provides undo and redo functionality\r\n *\r\n * @param initialPresent The initial value\r\n * @returns An object with the current state, undo and redo functions, and a setter\r\n */\r\nexport function useUndoRedo<T>(initialPresent: T) {\r\n  const initialState: HistoryState<T> = {\r\n    past: [],\r\n    present: initialPresent,\r\n    future: [],\r\n  };\r\n\r\n  const [state, dispatch] = useReducer(\r\n    (state: HistoryState<T>, action: HistoryAction<T>): HistoryState<T> => {\r\n      const { past, present, future } = state;\r\n\r\n      switch (action.type) {\r\n        case \"UNDO\": {\r\n          if (past.length === 0) return state;\r\n\r\n          const previous = past[past.length - 1];\r\n          const newPast = past.slice(0, past.length - 1);\r\n\r\n          return {\r\n            past: newPast,\r\n            present: previous,\r\n            future: [present, ...future],\r\n          };\r\n        }\r\n\r\n        case \"REDO\": {\r\n          if (future.length === 0) return state;\r\n\r\n          const next = future[0];\r\n          const newFuture = future.slice(1);\r\n\r\n          return {\r\n            past: [...past, present],\r\n            present: next,\r\n            future: newFuture,\r\n          };\r\n        }\r\n\r\n        case \"SET\": {\r\n          const { newPresent } = action;\r\n\r\n          if (newPresent === present) return state;\r\n\r\n          return {\r\n            past: [...past, present],\r\n            present: newPresent,\r\n            future: [],\r\n          };\r\n        }\r\n\r\n        case \"CLEAR\": {\r\n          return {\r\n            ...initialState,\r\n            present: action.initialPresent,\r\n          };\r\n        }\r\n      }\r\n    },\r\n    initialState,\r\n  );\r\n\r\n  const canUndo = state.past.length !== 0;\r\n  const canRedo = state.future.length !== 0;\r\n\r\n  const undo = useCallback(() => {\r\n    if (canUndo) {\r\n      dispatch({ type: \"UNDO\" });\r\n    }\r\n  }, [canUndo]);\r\n\r\n  const redo = useCallback(() => {\r\n    if (canRedo) {\r\n      dispatch({ type: \"REDO\" });\r\n    }\r\n  }, [canRedo]);\r\n\r\n  const set = useCallback((newPresent: T) => {\r\n    dispatch({ type: \"SET\", newPresent });\r\n  }, []);\r\n\r\n  const clear = useCallback(() => {\r\n    dispatch({ type: \"CLEAR\", initialPresent });\r\n  }, [initialPresent]);\r\n\r\n  return {\r\n    state: state.present,\r\n    set,\r\n    undo,\r\n    redo,\r\n    clear,\r\n    canUndo,\r\n    canRedo,\r\n    history: state,\r\n  };\r\n}\r\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}