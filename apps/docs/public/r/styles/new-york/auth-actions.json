{
  "$schema": "http://localhost:3001/schema/registry-item.json",
  "name": "auth-actions",
  "type": "registry:auth",
  "author": "axionjs (https://www.axionjs.com)",
  "description": "Actions for handling authentication.",
  "dependencies": [
    "bcryptjs",
    "zod",
    "next-auth@beta",
    "cloudinary",
    "uuid"
  ],
  "registryDependencies": [
    "prisma"
  ],
  "files": [
    {
      "path": "auth/actions/auth-actions.ts",
      "content": "\"use server\";\r\n\r\nimport * as z from \"zod\";\r\nimport { db } from \"@/registry/new-york/auth/lib/db\";\r\nimport { v2 as cloudinary } from \"cloudinary\";\r\nimport {\r\n  LoginSchema,\r\n  NewPasswordSchema,\r\n  ResetSchema,\r\n  SettingsSchema,\r\n} from \"@/registry/new-york/auth/schemas\";\r\nimport { RegisterSchema } from \"@/registry/new-york/auth/schemas\";\r\nimport { getUserByEmail, getUserById } from \"@/registry/new-york/auth/lib/user\";\r\nimport { signIn, signOut } from \"@/registry/new-york/auth/lib/auth\";\r\nimport { DEFAULT_LOGIN_REDIRECT } from \"@/registry/new-york/auth/lib/routes\";\r\nimport { AuthError } from \"next-auth\";\r\nimport {\r\n  generatePasswordResetToken,\r\n  generateVerificationToken,\r\n  getPasswordResetTokenByToken,\r\n  getVerificationTokenByToken,\r\n  hashPassword,\r\n  verifyPassword,\r\n} from \"@/registry/new-york/auth/lib/auth-helpers\";\r\nimport {\r\n  sendPasswordResetEmail,\r\n  sendVerificationEmail,\r\n  sendTwoFactorTokenEmail,\r\n} from \"@/registry/new-york/auth/lib/mail\";\r\nimport {\r\n  generateTwoFactorToken,\r\n  getTwoFactorConfirmationByUserId,\r\n  getTwoFactorTokenByEmail,\r\n} from \"@/registry/new-york/auth/actions/two-factor\";\r\nimport { currentUser } from \"@/registry/new-york/auth/lib/get-user\";\r\n\r\nexport const login = async (\r\n  values: z.infer<typeof LoginSchema>,\r\n  callbackUrl?: string | null,\r\n) => {\r\n  const validatedFields = LoginSchema.safeParse(values);\r\n  if (!validatedFields.success) {\r\n    return { error: \"Invalid fields!\" };\r\n  }\r\n\r\n  const { email, password, code } = validatedFields.data;\r\n\r\n  const existingUser = await getUserByEmail(email);\r\n  if (!existingUser || !existingUser.email || !existingUser.password) {\r\n    // Either user/email does not exist or user signed in with OAuth\r\n    return { error: \"Email does not exist! / Sign in with OAuth!\" };\r\n  }\r\n\r\n  const passwordsMatch = await verifyPassword(password, existingUser.password);\r\n\r\n  if (!existingUser.emailVerified) {\r\n    const verificationToken = await generateVerificationToken(\r\n      existingUser.email,\r\n    );\r\n\r\n    if (!passwordsMatch) {\r\n      return { error: \"Invalid credentials!\" };\r\n    }\r\n    await sendVerificationEmail(\r\n      verificationToken.email,\r\n      verificationToken.token,\r\n    );\r\n\r\n    return { success: \"Confirmation email sent!\" };\r\n  }\r\n  if (!passwordsMatch) {\r\n    return { error: \"Invalid credentials!\" };\r\n  }\r\n  //2FA\r\n  if (existingUser.isTwoFactorEnabled && existingUser.email) {\r\n    if (code) {\r\n      const twoFactorToken = await getTwoFactorTokenByEmail(existingUser.email);\r\n\r\n      if (!twoFactorToken) return { error: \"Invalid code!\" };\r\n\r\n      if (twoFactorToken.token !== code) return { error: \"Invalid code!\" };\r\n\r\n      const hasExpired = new Date(twoFactorToken.expires) < new Date();\r\n\r\n      if (hasExpired) return { error: \"Code expired!\" };\r\n\r\n      await db.twoFactorToken.delete({ where: { id: twoFactorToken.id } });\r\n\r\n      const existingConfirmation = await getTwoFactorConfirmationByUserId(\r\n        existingUser.id,\r\n      );\r\n\r\n      if (existingConfirmation) {\r\n        await db.twoFactorConfirmation.delete({\r\n          where: { id: existingConfirmation.id },\r\n        });\r\n      }\r\n\r\n      await db.twoFactorConfirmation.create({\r\n        data: {\r\n          userId: existingUser.id,\r\n        },\r\n      });\r\n    } else {\r\n      const twoFactorToken = await generateTwoFactorToken(existingUser.email);\r\n      await sendTwoFactorTokenEmail(twoFactorToken.email, twoFactorToken.token);\r\n\r\n      // when 2FA token has been emailed to user\r\n      return { twoFactor: true };\r\n    }\r\n  }\r\n\r\n  try {\r\n    await signIn(\"credentials\", {\r\n      email,\r\n      password,\r\n      redirectTo: callbackUrl || DEFAULT_LOGIN_REDIRECT,\r\n    }); // explicitly setting the redirect (for clarity), even though middleware will redirect if user is logged in\r\n\r\n    return { success: \"Logged in!\" };\r\n  } catch (error) {\r\n    if (error instanceof AuthError) {\r\n      switch (error.type) {\r\n        case \"CredentialsSignin\": {\r\n          return { error: \"Invalid credentials!\" };\r\n        }\r\n        default: {\r\n          return { error: \"Something went wrong!\" };\r\n        }\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const logout = async () => {\r\n  await signOut();\r\n};\r\n\r\nexport const register = async (values: z.infer<typeof RegisterSchema>) => {\r\n  const validatedFields = RegisterSchema.safeParse(values);\r\n  if (!validatedFields.success) {\r\n    return { error: \"Invalid fields!\" };\r\n  }\r\n\r\n  const { email, password, name } = validatedFields.data;\r\n  const hashedPassword = await hashPassword(password);\r\n\r\n  const existingUser = await getUserByEmail(email);\r\n\r\n  if (existingUser) {\r\n    return { error: \"Email already in use!\" };\r\n  }\r\n\r\n  await db.user.create({\r\n    data: {\r\n      email,\r\n      password: hashedPassword,\r\n      name,\r\n    },\r\n  });\r\n\r\n  const verificationToken = await generateVerificationToken(email);\r\n  await sendVerificationEmail(verificationToken.email, verificationToken.token);\r\n\r\n  return { success: \"Confirmation Email Sent!\" };\r\n};\r\n\r\nexport const loginWithOAuth = async (\r\n  provider: string,\r\n  callbackUrl?: string | null,\r\n) => {\r\n  try {\r\n    await signIn(provider, {\r\n      redirectTo: callbackUrl || DEFAULT_LOGIN_REDIRECT,\r\n    });\r\n\r\n    return { success: \"Logged in!\" };\r\n  } catch (error) {\r\n    if (error === \"NEXT_REDIRECT\") {\r\n      // This is a redirect, not an actual error\r\n      return { success: \"Redirecting to OAuth provider...\" };\r\n    } else if (error instanceof AuthError) {\r\n      switch (error.type) {\r\n        case \"OAuthAccountNotLinked\":\r\n          return {\r\n            error: \"Email is already in use with a different provider.\",\r\n          };\r\n        default:\r\n          return { error: \"Something went wrong.\" };\r\n      }\r\n    }\r\n    throw error;\r\n  }\r\n};\r\n\r\nexport const newVerification = async (token: string) => {\r\n  const existingToken = await getVerificationTokenByToken(token);\r\n  if (!existingToken) {\r\n    return { error: \"Token does not exist\" };\r\n  }\r\n\r\n  const hasExpired = new Date(existingToken.expires) < new Date();\r\n\r\n  if (hasExpired) {\r\n    return { error: \"Token has expired\" };\r\n  }\r\n\r\n  const existingUser = await getUserByEmail(existingToken.email);\r\n\r\n  // Handle case where user exists - normal email verification for new registration\r\n  if (existingUser) {\r\n    await db.user.update({\r\n      where: { id: existingUser.id },\r\n      data: {\r\n        emailVerified: new Date(),\r\n      },\r\n    });\r\n  } else {\r\n    // If we can't find a user with this email, it might be from a registration\r\n    // that created the user but didn't set the email yet\r\n    const pendingUser = await db.user.findFirst({\r\n      where: {\r\n        OR: [{ email: null }, { emailVerified: null }],\r\n      },\r\n      orderBy: {\r\n        id: \"desc\",\r\n      },\r\n    });\r\n\r\n    if (!pendingUser) {\r\n      return { error: \"User not found!\" };\r\n    }\r\n\r\n    await db.user.update({\r\n      where: { id: pendingUser.id },\r\n      data: {\r\n        email: existingToken.email,\r\n        emailVerified: new Date(),\r\n      },\r\n    });\r\n  }\r\n\r\n  await db.verificationToken.delete({\r\n    where: { id: existingToken.id },\r\n  });\r\n\r\n  return { success: \"Email verified!\" };\r\n};\r\n\r\nexport const reset = async (values: z.infer<typeof ResetSchema>) => {\r\n  const validatedFields = ResetSchema.safeParse(values);\r\n\r\n  if (!validatedFields.success) return { error: \"Invalid email!\" };\r\n\r\n  const { email } = validatedFields.data;\r\n\r\n  const existingUser = await getUserByEmail(email);\r\n  if (!existingUser) return { error: \"Email not found!\" };\r\n\r\n  const isOAuthAccount = await db.account.findFirst({\r\n    where: { userId: existingUser?.id },\r\n  });\r\n\r\n  if (isOAuthAccount)\r\n    return { error: \"Cannot reset password for OAuth account!\" };\r\n\r\n  const passwordResetToken = await generatePasswordResetToken(email);\r\n  await sendPasswordResetEmail(\r\n    passwordResetToken.email,\r\n    passwordResetToken.token,\r\n  );\r\n\r\n  return { success: \"Reset password email sent\" };\r\n};\r\n\r\nexport const newPassword = async (\r\n  values: z.infer<typeof NewPasswordSchema>,\r\n  token?: string | null,\r\n) => {\r\n  if (!token) return { error: \"Missing token!\" };\r\n\r\n  const validatedFields = NewPasswordSchema.safeParse(values);\r\n\r\n  if (!validatedFields.success) return { error: \"Invalid fields!\" };\r\n\r\n  const { password } = validatedFields.data;\r\n\r\n  const existingToken = await getPasswordResetTokenByToken(token);\r\n\r\n  if (!existingToken) return { error: \"Invalid token!\" };\r\n\r\n  const hasExpired = new Date(existingToken.expires) < new Date();\r\n\r\n  if (hasExpired) return { error: \"Token has expired!\" };\r\n\r\n  const existingUser = await getUserByEmail(existingToken.email);\r\n\r\n  if (!existingUser) return { error: \"Email does not exist!\" };\r\n\r\n  const hashedPassword = await hashPassword(password);\r\n\r\n  await db.user.update({\r\n    where: { id: existingUser.id },\r\n    data: { password: hashedPassword },\r\n  });\r\n\r\n  await db.passwordResetToken.delete({\r\n    where: { id: existingToken.id },\r\n  });\r\n\r\n  return { success: \"Password updated!\" };\r\n};\r\n\r\n// New action for email change\r\nexport async function changeEmail(userId: string, newEmail: string) {\r\n  const existingUser = await db.user.findUnique({\r\n    where: { id: userId },\r\n  });\r\n\r\n  if (!existingUser) {\r\n    return { error: \"User not found!\" };\r\n  }\r\n\r\n  // Check if the new email is already used by another account\r\n  const emailTaken = await getUserByEmail(newEmail);\r\n  if (emailTaken && emailTaken.id !== userId) {\r\n    return { error: \"Email already in use by another account!\" };\r\n  }\r\n\r\n  // Store the user ID in the verification token\r\n  const verificationToken = await generateVerificationToken(newEmail, userId);\r\n\r\n  // Send verification email to the NEW email address with emailChange flag\r\n  await sendVerificationEmail(\r\n    newEmail,\r\n    verificationToken.token,\r\n    true, // Indicate this is an email change\r\n  );\r\n\r\n  // Update user record to indicate pending email change\r\n  await db.user.update({\r\n    where: { id: userId },\r\n    data: {\r\n      pendingEmail: newEmail,\r\n    },\r\n  });\r\n\r\n  return { success: \"Verification email sent to new address!\" };\r\n}\r\n\r\n// Action to verify email change\r\nexport async function verifyEmailChange(token: string) {\r\n  const existingToken = await getVerificationTokenByToken(token);\r\n\r\n  if (!existingToken) {\r\n    return { error: \"Token does not exist!\" };\r\n  }\r\n\r\n  const hasExpired = new Date(existingToken.expires) < new Date();\r\n\r\n  if (hasExpired) {\r\n    return { error: \"Token has expired!\" };\r\n  }\r\n\r\n  // Find the user who requested this email change using the userId stored in the token\r\n  if (!existingToken.userId) {\r\n    return { error: \"Invalid email change request!\" };\r\n  }\r\n\r\n  const user = await db.user.findUnique({\r\n    where: { id: existingToken.userId },\r\n  });\r\n\r\n  if (!user) {\r\n    return { error: \"User not found!\" };\r\n  }\r\n\r\n  // Update the user's email\r\n  await db.user.update({\r\n    where: { id: user.id },\r\n    data: {\r\n      email: existingToken.email,\r\n      emailVerified: new Date(),\r\n      pendingEmail: null, // Clear the pending email field\r\n    },\r\n  });\r\n\r\n  // Delete the verification token\r\n  await db.verificationToken.delete({\r\n    where: { id: existingToken.id },\r\n  });\r\n\r\n  return { success: \"Email updated successfully!\" };\r\n}\r\n\r\nexport const settings = async (\r\n  userId: string | { id: string } | any,\r\n  values: z.infer<typeof SettingsSchema>,\r\n) => {\r\n  const user = await currentUser();\r\n\r\n  if (!user) return { error: \"Unauthorized!\" };\r\n  // Handle different userId formats\r\n  const actualUserId =\r\n    typeof userId === \"string\"\r\n      ? userId\r\n      : typeof userId === \"object\" && userId?.id\r\n        ? userId.id\r\n        : null;\r\n\r\n  if (!actualUserId) {\r\n    return { error: \"Invalid user ID!\" };\r\n  }\r\n\r\n  const dbUser = await getUserById(user.id as string);\r\n\r\n  if (!dbUser) return { error: \"Unauthorized!\" };\r\n\r\n  // users who signed in with OAuth should not be able to modify these fields\r\n  if (user.isOAuth) {\r\n    values.email = undefined;\r\n    values.isTwoFactorEnabled = undefined;\r\n  }\r\n\r\n  // Handle email change if provided\r\n  if (values.email && values.email !== user.email) {\r\n    return await changeEmail(actualUserId, values.email);\r\n  }\r\n\r\n  // Handle name update\r\n  if (values.name !== undefined && values.name !== user.name) {\r\n    await db.user.update({\r\n      where: { id: actualUserId },\r\n      data: { name: values.name },\r\n    });\r\n  }\r\n\r\n  // Handle two-factor authentication toggle\r\n  if (\r\n    typeof values.isTwoFactorEnabled !== \"undefined\" &&\r\n    values.isTwoFactorEnabled !== dbUser.isTwoFactorEnabled\r\n  ) {\r\n    await db.user.update({\r\n      where: { id: actualUserId },\r\n      data: { isTwoFactorEnabled: values.isTwoFactorEnabled },\r\n    });\r\n  }\r\n\r\n  return { success: \"Profile updated!\" };\r\n};\r\n\r\n// Configure Cloudinary\r\ncloudinary.config({\r\n  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,\r\n  api_key: process.env.CLOUDINARY_API_KEY,\r\n  api_secret: process.env.CLOUDINARY_API_SECRET,\r\n});\r\n\r\nexport async function updateUserImage(userId: string, imageData: string) {\r\n  try {\r\n    // Validate user ID\r\n    const user = await db.user.findUnique({\r\n      where: { id: userId },\r\n    });\r\n\r\n    if (!user) {\r\n      return { error: \"User not found!\" };\r\n    }\r\n\r\n    if (!imageData || !imageData.startsWith(\"data:image/\")) {\r\n      return { error: \"Invalid image data!\" };\r\n    }\r\n\r\n    // Upload to Cloudinary\r\n    const uploadResponse = await new Promise((resolve, reject) => {\r\n      cloudinary.uploader.upload(\r\n        imageData,\r\n        {\r\n          folder: \"user_profiles\",\r\n          // You can add transformation options here\r\n          // transformation: [{ width: 250, height: 250, crop: 'fill' }]\r\n        },\r\n        (error, result) => {\r\n          if (error) reject(error);\r\n          else resolve(result);\r\n        },\r\n      );\r\n    });\r\n\r\n    // Get the secure URL from the upload response\r\n    const imageUrl = (uploadResponse as { secure_url: string }).secure_url;\r\n\r\n    // Update the user's image URL in the database\r\n    await db.user.update({\r\n      where: { id: userId },\r\n      data: { image: imageUrl },\r\n    });\r\n\r\n    return { success: \"Profile picture updated!\" };\r\n  } catch (error) {\r\n    console.error(\"Error updating profile picture:\", error);\r\n    return { error: \"Failed to update profile picture.\" };\r\n  }\r\n}\r\n\r\nexport const changePassword = async (\r\n  currentPassword: string,\r\n  newPassword: string,\r\n) => {\r\n  const user = await currentUser();\r\n\r\n  if (!user) return { error: \"Unauthorized!\" };\r\n\r\n  // Block OAuth users from password changes\r\n  if (user.isOAuth) {\r\n    return { error: \"OAuth users cannot change password!\" };\r\n  }\r\n\r\n  const dbUser = await getUserById(user.id as string);\r\n\r\n  if (!dbUser) return { error: \"Unauthorized!\" };\r\n\r\n  const passwordsMatch = await verifyPassword(\r\n    currentPassword,\r\n    dbUser?.password!,\r\n  );\r\n\r\n  if (!passwordsMatch) {\r\n    return { error: \"Incorrect password!\" };\r\n  }\r\n\r\n  const hashedPassword = await hashPassword(newPassword);\r\n\r\n  await db.user.update({\r\n    where: { id: dbUser.id },\r\n    data: { password: hashedPassword },\r\n  });\r\n\r\n  return { success: \"Password updated!\" };\r\n};\r\n",
      "type": "registry:actions",
      "target": ""
    },
    {
      "path": "auth/lib/auth-helpers.ts",
      "content": "import { db } from \"@/registry/new-york/auth/lib/db\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport bcryptjs from \"bcryptjs\";\r\n\r\nexport const hashPassword = async (password: string) => {\r\n  return await bcryptjs.hash(password, 10);\r\n};\r\n\r\nexport const verifyPassword = async (\r\n  inputPassword: string,\r\n  hashedPassword: string,\r\n) => {\r\n  return await bcryptjs.compare(inputPassword, hashedPassword);\r\n};\r\n\r\nexport const getVerificationTokenByToken = async (token: string) => {\r\n  try {\r\n    const verificationToken = await db.verificationToken.findUnique({\r\n      where: { token },\r\n    });\r\n\r\n    return verificationToken;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getVerificationTokenByEmail = async (email: string) => {\r\n  try {\r\n    const verificationToken = await db.verificationToken.findFirst({\r\n      where: { email },\r\n    });\r\n\r\n    return verificationToken;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const generateVerificationToken = async (\r\n  email: string,\r\n  userId?: string,\r\n) => {\r\n  const token = uuidv4();\r\n  const expires = new Date(new Date().getTime() + 3600 * 1000);\r\n\r\n  const existingToken = await getVerificationTokenByEmail(email);\r\n\r\n  if (existingToken) {\r\n    await db.verificationToken.delete({\r\n      where: { id: existingToken.id },\r\n    });\r\n  }\r\n\r\n  const verificationToken = await db.verificationToken.create({\r\n    data: {\r\n      email,\r\n      token,\r\n      expires,\r\n      userId, // Will be undefined for new registrations, populated for email changes\r\n    },\r\n  });\r\n\r\n  return verificationToken;\r\n};\r\n\r\nexport const getPasswordResetTokenByToken = async (token: string) => {\r\n  try {\r\n    const passwordResetToken = await db.passwordResetToken.findUnique({\r\n      where: {\r\n        token,\r\n      },\r\n    });\r\n    return passwordResetToken;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getPasswordResetTokenByEmail = async (email: string) => {\r\n  try {\r\n    const passwordResetToken = await db.passwordResetToken.findFirst({\r\n      where: {\r\n        email,\r\n      },\r\n    });\r\n    return passwordResetToken;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const generatePasswordResetToken = async (email: string) => {\r\n  const token = uuidv4();\r\n  const expires = new Date(new Date().getTime() + 3600 * 1000);\r\n\r\n  const existingToken = await getPasswordResetTokenByEmail(email);\r\n\r\n  if (existingToken) {\r\n    await db.passwordResetToken.delete({\r\n      where: { id: existingToken.id },\r\n    });\r\n  }\r\n\r\n  const passwordResetToken = await db.passwordResetToken.create({\r\n    data: {\r\n      email,\r\n      token,\r\n      expires,\r\n    },\r\n  });\r\n\r\n  return passwordResetToken;\r\n};\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/user.ts",
      "content": "import { db } from \"@/registry/new-york/auth/lib/db\";\r\n\r\nexport const getUserByEmail = async (email: string) => {\r\n  try {\r\n    const user = await db.user.findFirst({\r\n      where: { email },\r\n    });\r\n    return user;\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n};\r\nexport const getUpdatedEmailUser = async (email: string) => {\r\n  try {\r\n    const user = await db.verificationToken.findFirst({\r\n      where: { email },\r\n    });\r\n    return user;\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getUserById = async (id: string) => {\r\n  try {\r\n    const user = await db.user.findFirst({\r\n      where: { id },\r\n    });\r\n    return user;\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n};\r\n\r\nexport const getAccountByUserId = async (userId: string) => {\r\n  try {\r\n    const account = await db.account.findFirst({\r\n      where: {\r\n        userId,\r\n      },\r\n    });\r\n\r\n    return account;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/auth.ts",
      "content": "import NextAuth from \"next-auth\";\r\nimport { PrismaAdapter } from \"@auth/prisma-adapter\";\r\nimport authConfig from \"@/registry/new-york/auth/lib/auth.config\";\r\nimport { db } from \"@/registry/new-york/auth/lib/db\";\r\nimport {\r\n  getAccountByUserId,\r\n  getUserById,\r\n} from \"@/registry/new-york/auth/lib/user\";\r\nimport { getTwoFactorConfirmationByUserId } from \"@/registry/new-york/auth/actions/two-factor\";\r\n\r\nexport const { auth, handlers, signIn, signOut } = NextAuth({\r\n  pages: {\r\n    signIn: \"/auth/login\",\r\n    error: \"/auth/error\",\r\n  },\r\n  events: {\r\n    async linkAccount({ user }) {\r\n      await db.user.update({\r\n        where: { id: user.id },\r\n        data: { emailVerified: new Date() },\r\n      });\r\n    },\r\n  },\r\n  callbacks: {\r\n    async signIn({ user, account }) {\r\n      //Allow OAuth without email verification\r\n      if (account?.type !== \"credentials\") return true;\r\n      const existingUser = await getUserById(user.id!);\r\n\r\n      //Prevent login if email is not verified\r\n      if (!existingUser?.emailVerified) return false;\r\n\r\n      //2FA Check\r\n      if (existingUser.isTwoFactorEnabled) {\r\n        const twoFactorConfirmation = await getTwoFactorConfirmationByUserId(\r\n          existingUser.id,\r\n        );\r\n\r\n        if (!twoFactorConfirmation) return false;\r\n\r\n        // Delete two factor confirmation for next sign in\r\n        await db.twoFactorConfirmation.delete({\r\n          where: { id: twoFactorConfirmation.id },\r\n        });\r\n      }\r\n\r\n      return true;\r\n    },\r\n    async session({ session, token }) {\r\n      if (token.sub && session.user) {\r\n        session.user.id = token.sub;\r\n      }\r\n      if (token.role && session.user) {\r\n        session.user.role = token.role;\r\n      }\r\n\r\n      if (session.user) {\r\n        session.user.isTwoFactorEnabled = token.isTwoFactorEnabled;\r\n      }\r\n\r\n      // model fields that can be updated by the user in the settings page\r\n      if (session.user) {\r\n        session.user.name = token.name;\r\n        session.user.email = token.email as string;\r\n        session.user.isOAuth = token.isOAuth;\r\n        session.user.image = token.image as string;\r\n      }\r\n      return session;\r\n    },\r\n\r\n    async jwt({ token }) {\r\n      if (!token.sub) {\r\n        return token;\r\n      }\r\n\r\n      const existingUser = await getUserById(token.sub);\r\n\r\n      if (!existingUser) {\r\n        return token;\r\n      }\r\n      const existingAccount = await getAccountByUserId(existingUser.id);\r\n\r\n      token.role = existingUser.role;\r\n      token.isTwoFactorEnabled = existingUser.isTwoFactorEnabled;\r\n\r\n      // model fields that can be updated by the user in the settings page\r\n      token.name = existingUser.name;\r\n      token.email = existingUser.email;\r\n      token.image = existingUser.image;\r\n\r\n      // type conversion to boolean\r\n      token.isOAuth = !!existingAccount;\r\n\r\n      return token;\r\n    },\r\n  },\r\n  adapter: PrismaAdapter(db),\r\n  session: { strategy: \"jwt\" },\r\n  ...authConfig,\r\n});\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/next-auth.d.ts",
      "content": "import { UserRole } from \"@prisma/client\";\r\nimport NextAuth, { type DefaultSession } from \"next-auth\";\r\nimport { JWT } from \"next-auth/jwt\";\r\n\r\ndeclare module \"next-auth/jwt\" {\r\n  interface JWT {\r\n    role: UserRole;\r\n    isTwoFactorEnabled: boolean;\r\n    isOAuth: boolean;\r\n  }\r\n}\r\n\r\nexport type ExtendedUser = DefaultSession[\"user\"] & {\r\n  role: UserRole;\r\n  isTwoFactorEnabled: boolean;\r\n  isOAuth: boolean;\r\n};\r\n\r\ndeclare module \"next-auth\" {\r\n  interface Session {\r\n    user: ExtendedUser;\r\n  }\r\n}\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/routes.ts",
      "content": "export const publicRoutes = [\"/\", \"/auth/verify\"];\r\n\r\n/**\r\n * An array of routes that are accessible only to authenticated users.\r\n * @type {string[]}\r\n */\r\nexport const authRoutes = [\r\n  \"/auth/login\",\r\n  \"/auth/register\",\r\n  \"/auth/error\",\r\n  \"/auth/reset\",\r\n  \"/auth/new-password\",\r\n];\r\n\r\n/**\r\n * An array of routes that are accessible only to admin users.\r\n * @type {string[]}\r\n */\r\nexport const adminRoutes = [\r\n  \"/admin\",\r\n  // Add other admin routes here\r\n];\r\n\r\n/**\r\n * The prefix for all API auth routes.\r\n * @type {string}\r\n */\r\nexport const apiAuthPrefix = \"/api/auth\";\r\n\r\n/**\r\n * The default redirect path after a successful login.\r\n * @type {string}\r\n */\r\nexport const DEFAULT_LOGIN_REDIRECT = \"/dashboard\";\r\n",
      "type": "registry:lib",
      "target": ""
    },
    {
      "path": "auth/lib/auth.config.ts",
      "content": "import Credentials from \"next-auth/providers/credentials\";\r\n\r\nimport { LoginSchema } from \"@/registry/new-york/auth/schemas\";\r\nimport GitHub from \"next-auth/providers/github\";\r\nimport type { NextAuthConfig } from \"next-auth\";\r\nimport Google from \"next-auth/providers/google\";\r\nimport { getUserByEmail } from \"@/registry/new-york/auth/lib/user\";\r\nimport { verifyPassword } from \"@/registry/new-york/auth/lib/auth-helpers\";\r\n\r\nexport default {\r\n  providers: [\r\n    Google({\r\n      clientId: process.env.GOOGLE_CLIENT_ID,\r\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET,\r\n    }),\r\n    GitHub({\r\n      clientId: process.env.GITHUB_CLIENT_ID,\r\n      clientSecret: process.env.GITHUB_CLIENT_SECRET,\r\n    }),\r\n    Credentials({\r\n      async authorize(credentials) {\r\n        const validatedFields = LoginSchema.safeParse(credentials);\r\n\r\n        if (validatedFields.success) {\r\n          const { email, password } = validatedFields.data;\r\n          const user = await getUserByEmail(email);\r\n\r\n          if (!user || !user.password) return null;\r\n\r\n          const passwordsMatch = await verifyPassword(password, user.password);\r\n\r\n          if (passwordsMatch) return user;\r\n        }\r\n        return null;\r\n      },\r\n    }),\r\n  ],\r\n} satisfies NextAuthConfig;\r\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}