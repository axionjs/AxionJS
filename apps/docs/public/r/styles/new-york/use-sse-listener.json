{
  "$schema": "https://www.axionjs.com/schema/registry-item.json",
  "name": "use-sse-listener",
  "type": "registry:hook",
  "author": "axionjs (https://www.axionjs.com)",
  "files": [
    {
      "path": "hooks/use-sse-listener.tsx",
      "content": "import { useEffect, useState, useRef, useCallback } from \"react\";\n\ninterface SseOptions {\n  /** URL for the SSE endpoint */\n  url: string;\n  /** Whether to connect immediately (default: true) */\n  autoConnect?: boolean;\n  /** Custom headers for the EventSource connection */\n  headers?: Record<string, string>;\n  /** Reconnect timeout in milliseconds (default: 5000) */\n  reconnectTimeout?: number;\n  /** Map of event types to listen for (in addition to 'message') */\n  events?: string[];\n  /** Whether to use withCredentials (default: false) */\n  withCredentials?: boolean;\n  /** Optional retry limit, after which reconnection attempts will stop */\n  maxRetries?: number;\n}\n\ntype SseStatus = \"IDLE\" | \"CONNECTING\" | \"OPEN\" | \"CLOSED\" | \"ERROR\";\n\ninterface SseEvent {\n  type: string;\n  data: any;\n  id?: string;\n  retry?: number;\n  lastEventId?: string;\n  timestamp: number;\n}\n\n/**\n * Custom hook for Server-Sent Events (SSE) with reconnection logic\n *\n * @param options Configuration options for the SSE connection\n * @returns Object containing connection status and control functions\n */\nexport function useSseListener(options: SseOptions) {\n  const {\n    url,\n    autoConnect = true,\n    headers = {},\n    reconnectTimeout = 5000,\n    events = [],\n    withCredentials = false,\n    maxRetries,\n  } = options;\n\n  const [status, setStatus] = useState<SseStatus>(\"IDLE\");\n  const [events$, setEvents] = useState<SseEvent[]>([]);\n  const [lastEvent, setLastEvent] = useState<SseEvent | null>(null);\n  const [error, setError] = useState<Error | null>(null);\n  const [retryCount, setRetryCount] = useState(0);\n\n  const eventSourceRef = useRef<EventSource | null>(null);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const cleanup = useCallback(() => {\n    if (eventSourceRef.current) {\n      eventSourceRef.current.close();\n      eventSourceRef.current = null;\n    }\n\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n  }, []);\n\n  const connect = useCallback(() => {\n    cleanup();\n\n    if (maxRetries !== undefined && retryCount >= maxRetries) {\n      setStatus(\"CLOSED\");\n      return;\n    }\n\n    try {\n      setStatus(\"CONNECTING\");\n\n      // For custom headers, we need to use a proxy server or polyfill\n      // since native EventSource doesn't support custom headers\n      if (Object.keys(headers).length > 0) {\n        // This implementation assumes you're using a proxy server or middleware\n        // that handles the headers, or you're using a polyfill like 'event-source-polyfill'\n        const queryParams = new URLSearchParams();\n\n        // Add headers as query parameters for the proxy to handle\n        Object.entries(headers).forEach(([key, value]) => {\n          queryParams.append(`header-${key}`, value);\n        });\n\n        const urlWithHeaders = `${url}${url.includes(\"?\") ? \"&\" : \"?\"}${queryParams.toString()}`;\n        eventSourceRef.current = new EventSource(urlWithHeaders, {\n          withCredentials,\n        });\n      } else {\n        eventSourceRef.current = new EventSource(url, { withCredentials });\n      }\n\n      // Handle connection opening\n      eventSourceRef.current.onopen = () => {\n        setStatus(\"OPEN\");\n        setError(null);\n        setRetryCount(0); // Reset retry count on successful connection\n      };\n\n      // Handle generic messages\n      eventSourceRef.current.onmessage = (event) => {\n        try {\n          const parsedData = JSON.parse(event.data);\n          const newEvent: SseEvent = {\n            type: \"message\",\n            data: parsedData,\n            id: event.lastEventId,\n            lastEventId: event.lastEventId,\n            timestamp: Date.now(),\n          };\n\n          setEvents((prev) => [...prev, newEvent]);\n          setLastEvent(newEvent);\n        } catch (e) {\n          // Handle non-JSON data\n          const newEvent: SseEvent = {\n            type: \"message\",\n            data: event.data,\n            id: event.lastEventId,\n            lastEventId: event.lastEventId,\n            timestamp: Date.now(),\n          };\n\n          setEvents((prev) => [...prev, newEvent]);\n          setLastEvent(newEvent);\n        }\n      };\n\n      // Add listeners for custom events\n      events.forEach((eventType) => {\n        eventSourceRef.current?.addEventListener(eventType, (event) => {\n          try {\n            const parsedData = JSON.parse(event.data);\n            const newEvent: SseEvent = {\n              type: eventType,\n              data: parsedData,\n              id: event.lastEventId,\n              lastEventId: event.lastEventId,\n              timestamp: Date.now(),\n            };\n\n            setEvents((prev) => [...prev, newEvent]);\n            setLastEvent(newEvent);\n          } catch (e) {\n            // Handle non-JSON data\n            const newEvent: SseEvent = {\n              type: eventType,\n              data: event.data,\n              id: event.lastEventId,\n              lastEventId: event.lastEventId,\n              timestamp: Date.now(),\n            };\n\n            setEvents((prev) => [...prev, newEvent]);\n            setLastEvent(newEvent);\n          }\n        });\n      });\n\n      // Handle errors\n      eventSourceRef.current.onerror = (e) => {\n        setStatus(\"ERROR\");\n        setError(new Error(\"SSE connection error\"));\n\n        // Attempt to reconnect\n        cleanup();\n        setRetryCount((prev) => prev + 1);\n\n        timeoutRef.current = setTimeout(() => {\n          connect();\n        }, reconnectTimeout);\n      };\n    } catch (e) {\n      setStatus(\"ERROR\");\n      setError(e instanceof Error ? e : new Error(\"Unknown SSE error\"));\n\n      // Attempt to reconnect\n      cleanup();\n      setRetryCount((prev) => prev + 1);\n\n      timeoutRef.current = setTimeout(() => {\n        connect();\n      }, reconnectTimeout);\n    }\n  }, [\n    url,\n    headers,\n    cleanup,\n    events,\n    reconnectTimeout,\n    withCredentials,\n    retryCount,\n    maxRetries,\n  ]);\n\n  const disconnect = useCallback(() => {\n    cleanup();\n    setStatus(\"CLOSED\");\n  }, [cleanup]);\n\n  // Connect automatically if autoConnect is true\n  useEffect(() => {\n    if (autoConnect) {\n      connect();\n    }\n\n    return () => {\n      cleanup();\n    };\n  }, [autoConnect, connect, cleanup]);\n\n  return {\n    status,\n    events: events$,\n    lastEvent,\n    error,\n    connect,\n    disconnect,\n    retryCount,\n  };\n}\n",
      "type": "registry:hook",
      "target": ""
    }
  ]
}