import { existsSync, promises as fs } from "fs";
import { tmpdir } from "os";
import path from "path";
import template from "lodash/template";
import { themes } from "../registry/registry-themes";
import { rimraf } from "rimraf";
import {
  Registry,
  registryItemSchema,
  registryItemTypeSchema,
  registrySchema,
} from "../registry/schema";
import { Project, ScriptKind } from "ts-morph";
import { z } from "zod";
import { registry } from "../registry";
import { iconLibraries, icons } from "../registry/registry-icons";
import { styles } from "../registry/registry-styles";

const REGISTRY_PATH = path.join(process.cwd(), "public/r");

const REGISTRY_INDEX_WHITELIST: z.infer<typeof registryItemTypeSchema>[] = [
  "registry:ui",
  "registry:lib",
  "registry:hook",
  "registry:theme",
  "registry:block",
  "registry:example",
  "registry:internal",
  "registry:dynamic-component",
];

const project = new Project({
  compilerOptions: {},
});

async function createTempSourceFile(filename: string) {
  const dir = await fs.mkdtemp(path.join(tmpdir(), "axionjs-"));
  return path.join(dir, filename);
}

// ----------------------------------------------------------------------------
// Sync styles
// ----------------------------------------------------------------------------
async function syncStyles() {
  const sourceStyle = "new-york";
  const targetStyle = "default";

  const syncDirectories = [
    "blocks",
    "hooks",
    "internal",
    "lib",
    "charts",
    "dynamic-components",
  ];

  // Clean up sync directories.
  for (const dir of syncDirectories) {
    rimraf.sync(path.join("registry", targetStyle, dir));
  }

  for (const item of registry.items) {
    if (
      !REGISTRY_INDEX_WHITELIST.includes(item.type) &&
      item.type !== "registry:ui"
    ) {
      continue;
    }

    const resolveFiles = item.files?.map(
      (file) =>
        `registry/${sourceStyle}/${typeof file === "string" ? file : file.path}`
    );
    if (!resolveFiles) {
      continue;
    }

    // Copy files to target style if they don't exist.
    for (const file of resolveFiles) {
      const sourcePath = path.join(process.cwd(), file);
      const targetPath = path.join(
        process.cwd(),
        file.replace(sourceStyle, targetStyle)
      );

      if (!existsSync(targetPath)) {
        // Create directory if it doesn't exist.
        await fs.mkdir(path.dirname(targetPath), { recursive: true });
        await fs.copyFile(sourcePath, targetPath);

        // Replace all @/registry/new-york/ with @/registry/default/.
        const content = await fs.readFile(targetPath, "utf8");
        const fixedContent = content.replace(
          new RegExp(`@/registry/${sourceStyle}/`, "g"),
          `@/registry/${targetStyle}/`
        );
        await fs.writeFile(targetPath, fixedContent, "utf8");
      }
    }
  }
}

async function buildRegistryJsonFile() {
  // 1. Fix the path for registry items.
  const fixedRegistry = {
    ...registry,
    items: registry.items.map((item) => {
      const files = item.files?.map((file) => {
        return {
          ...file,
          path: `${file.path}`,
        };
      });

      return {
        ...item,
        files,
      };
    }),
  };

  // 2. Write the content of the registry to `registry.json` and public folder
  rimraf.sync(path.join(process.cwd(), `registry.json`));
  rimraf.sync(path.join(process.cwd(), `public/registry.json`));

  const registryJson = JSON.stringify(fixedRegistry, null, 2);

  await fs.writeFile(path.join(process.cwd(), `registry.json`), registryJson);
  await fs.writeFile(
    path.join(process.cwd(), `public/registry.json`),
    registryJson
  );
}

// ----------------------------------------------------------------------------
// Build __registry__/index.tsx.
// ----------------------------------------------------------------------------
async function buildRegistry(registry: Registry) {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Index: Record<string, any> = {
`;

  for (const style of styles) {
    index += `  "${style.name}": {`;

    // Build style index.
    for (const item of registry.items) {
      const resolveFiles = item.files?.map(
        (file) =>
          `registry/${style.name}/${
            typeof file === "string" ? file : file.path
          }`
      );
      if (!resolveFiles) {
        continue;
      }

      const type = item.type.split(":")[1];
      let sourceFilename = "";

      if (
        item.type === "registry:block" ||
        item.type === "registry:dynamic-component"
      ) {
        const file = resolveFiles[0];
        const filename = path.basename(file);
        let raw: string;
        try {
          raw = await fs.readFile(file, "utf8");
        } catch (error) {
          continue;
        }
        const tempFile = await createTempSourceFile(filename);
        const sourceFile = project.createSourceFile(tempFile, raw, {
          scriptKind: ScriptKind.TSX,
        });

        // Find all imports.
        const imports = new Map<
          string,
          {
            module: string;
            text: string;
            isDefault?: boolean;
          }
        >();
        sourceFile.getImportDeclarations().forEach((node) => {
          const module = node.getModuleSpecifier().getLiteralValue();
          node.getNamedImports().forEach((item) => {
            imports.set(item.getText(), {
              module,
              text: node.getText(),
            });
          });

          const defaultImport = node.getDefaultImport();
          if (defaultImport) {
            imports.set(defaultImport.getText(), {
              module,
              text: defaultImport.getText(),
              isDefault: true,
            });
          }
        });

        // Write the source file for blocks only.
        sourceFilename = `__registry__/${style.name}/${type}/${item.name}.tsx`;

        if (item.files) {
          const files = item.files.map((file) =>
            typeof file === "string"
              ? { type: "registry:page", path: file }
              : file
          );
          if (files?.length) {
            sourceFilename = `__registry__/${style.name}/${files[0].path}`;
          }
        }

        const sourcePath = path.join(process.cwd(), sourceFilename);
        if (!existsSync(sourcePath)) {
          await fs.mkdir(sourcePath, { recursive: true });
        }

        rimraf.sync(sourcePath);
        await fs.writeFile(sourcePath, sourceFile.getText());
      }

      let componentPath = `@/registry/${style.name}/${type}/${item.name}`;

      if (item.files) {
        const files = item.files.map((file) =>
          typeof file === "string"
            ? { type: "registry:page", path: file }
            : file
        );
        if (files?.length) {
          componentPath = `@/registry/${style.name}/${files[0].path}`;
        }
      }

      index += `
    "${item.name}": {
      name: "${item.name}",
      description: "${item.description ?? ""}",
      type: "${item.type}",
      registryDependencies: ${JSON.stringify(item.registryDependencies)},
      files: [${item.files?.map((file) => {
        const filePath = `registry/${style.name}/${
          typeof file === "string" ? file : file.path
        }`;
        const resolvedFilePath = path.resolve(filePath);
        return typeof file === "string"
          ? `"${resolvedFilePath}"`
          : `{
        path: "${filePath}",
        type: "${file.type}",
        target: "${file.target ?? ""}"
      }`;
      })}],
      categories: ${JSON.stringify(item.categories)},
      component: React.lazy(() => import("${componentPath}")),
      source: "${sourceFilename}",
      meta: ${JSON.stringify(item.meta)},
    },`;
    }

    index += `
  },`;
  }

  index += `
}
`;

  // ----------------------------------------------------------------------------
  // Build registry/index.json.
  // ----------------------------------------------------------------------------
  const items = registry.items
    .filter((item) => ["registry:ui", "registry:hook"].includes(item.type))
    .map((item) => {
      return {
        ...item,
        files: item.files?.map((_file) => {
          const file =
            typeof _file === "string"
              ? {
                  path: _file,
                  type: item.type,
                }
              : _file;

          return file;
        }),
      };
    });
  const registryJson = JSON.stringify(items, null, 2);
  rimraf.sync(path.join(REGISTRY_PATH, "index.json"));
  await fs.writeFile(
    path.join(REGISTRY_PATH, "index.json"),
    registryJson,
    "utf8"
  );

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/index.tsx"));
  await fs.writeFile(path.join(process.cwd(), "__registry__/index.tsx"), index);
}

// ----------------------------------------------------------------------------
// Build registry/styles/[style]/[name].json.
// ----------------------------------------------------------------------------
async function buildStyles(registry: Registry) {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, "styles", style.name);

    // Create directory if it doesn't exist.
    if (!existsSync(targetPath)) {
      await fs.mkdir(targetPath, { recursive: true });
    }

    for (const item of registry.items) {
      if (!REGISTRY_INDEX_WHITELIST.includes(item.type)) {
        continue;
      }

      let files;
      if (item.files) {
        files = await Promise.all(
          item.files.map(async (_file) => {
            const file =
              typeof _file === "string"
                ? {
                    path: _file,
                    type: item.type,
                    content: "",
                    target: "",
                  }
                : _file;

            let content: string;
            try {
              content = await fs.readFile(
                path.join(process.cwd(), "registry", style.name, file.path),
                "utf8"
              );
            } catch (error) {
              return;
            }

            const tempFile = await createTempSourceFile(file.path);
            const sourceFile = project.createSourceFile(tempFile, content, {
              scriptKind: ScriptKind.TSX,
            });

            sourceFile.getVariableDeclaration("iframeHeight")?.remove();
            sourceFile.getVariableDeclaration("containerClassName")?.remove();
            sourceFile.getVariableDeclaration("description")?.remove();

            let target = file.target || "";

            if ((!target || target === "") && item.name.startsWith("v0-")) {
              const fileName = file.path.split("/").pop();
              if (
                file.type === "registry:block" ||
                file.type === "registry:component" ||
                file.type === "registry:example"
              ) {
                target = `components/${fileName}`;
              }

              if (file.type === "registry:ui") {
                target = `components/ui/${fileName}`;
              }

              if (file.type === "registry:hook") {
                target = `hooks/${fileName}`;
              }

              if (file.type === "registry:lib") {
                target = `lib/${fileName}`;
              }
            }

            return {
              path: file.path,
              type: file.type,
              content: sourceFile.getText(),
              target,
            };
          })
        );
      }

      const payload = registryItemSchema.safeParse({
        $schema: "http://localhost:3001/schema/registry-item.json",
        author: "axionjs (https://www.axionjs.com)",
        ...item,
        files,
      });

      if (payload.success) {
        await fs.writeFile(
          path.join(targetPath, `${item.name}.json`),
          JSON.stringify(payload.data, null, 2),
          "utf8"
        );
      }
    }
  }

  // ----------------------------------------------------------------------------
  // Build registry/styles/index.json.
  // ----------------------------------------------------------------------------
  const stylesJson = JSON.stringify(styles, null, 2);
  await fs.writeFile(
    path.join(REGISTRY_PATH, "styles/index.json"),
    stylesJson,
    "utf8"
  );
}

// ----------------------------------------------------------------------------
// Build registry/styles/[name]/index.json.
// ----------------------------------------------------------------------------
async function buildStylesIndex() {
  for (const style of styles) {
    const targetPath = path.join(REGISTRY_PATH, "styles", style.name);

    const payload: z.infer<typeof registryItemSchema> = {
      name: style.name,
      type: "registry:style",
      dependencies: [
        "tailwindcss-animate",
        "class-variance-authority",
        "lucide-react",
      ],
      registryDependencies: ["utils"],
      tailwind: {
        config: {
          theme: {
            extend: {
              colors: {
                background: "hsl(var(--background))",
                foreground: "hsl(var(--foreground))",
                card: {
                  DEFAULT: "hsl(var(--card))",
                  foreground: "hsl(var(--card-foreground))",
                },
                popover: {
                  DEFAULT: "hsl(var(--popover))",
                  foreground: "hsl(var(--popover-foreground))",
                },
                primary: {
                  DEFAULT: "hsl(var(--primary))",
                  foreground: "hsl(var(--primary-foreground))",
                },
                secondary: {
                  DEFAULT: "hsl(var(--secondary))",
                  foreground: "hsl(var(--secondary-foreground))",
                },
                muted: {
                  DEFAULT: "hsl(var(--muted))",
                  foreground: "hsl(var(--muted-foreground))",
                },
                accent: {
                  DEFAULT: "hsl(var(--accent))",
                  foreground: "hsl(var(--accent-foreground))",
                },
                destructive: {
                  DEFAULT: "hsl(var(--destructive))",
                  foreground: "hsl(var(--destructive-foreground))",
                },
                border: "hsl(var(--border))",
                input: "hsl(var(--input))",
                ring: "hsl(var(--ring))",
              },
              borderRadius: {
                lg: "var(--radius)",
                md: "calc(var(--radius) - 2px)",
                sm: "calc(var(--radius) - 4px)",
                xl: "calc(var(--radius) + 2px)",
              },
              fontFamily: {
                display: ["var(--font-display)", "sans-serif"],
                text: ["var(--font-text)", "sans-serif"],
              },
              keyframes: {
                shine: {
                  from: { backgroundPosition: "200% 0" },
                  to: { backgroundPosition: "-200% 0" },
                },
                fadeIn: {
                  "0%": { opacity: "0" },
                  "100%": { opacity: "1" },
                },
                fadeOut: {
                  "0%": { opacity: "1" },
                  "100%": { opacity: "0" },
                },
                scaleUp: {
                  "0%": { transform: "scale(0.95)" },
                  "100%": { transform: "scale(1)" },
                },
                scaleDown: {
                  "0%": { transform: "scale(1)" },
                  "100%": { transform: "scale(0.95)" },
                },
                slideIn: {
                  "0%": { transform: "translateX(-100%)" },
                  "100%": { transform: "translateX(0)" },
                },
                slideOut: {
                  "0%": { transform: "translateX(0)" },
                  "100%": { transform: "translateX(-100%)" },
                },
                marquee: {
                  from: { transform: "translateX(0)" },
                  to: { transform: "translateX(calc(-100% - var(--gap)))" },
                },
                "marquee-vertical": {
                  from: { transform: "translateY(0)" },
                  to: { transform: "translateY(calc(-100% - var(--gap)))" },
                },
              },
              animation: {
                fadeIn: "fadeIn 500ms ease",
                fadeOut: "fadeOut 500ms ease",
                scaleUp: "scaleUp 300ms ease",
                scaleDown: "scaleDown 300ms ease",
                slideIn: "slideIn 500ms ease",
                slideOut: "slideOut 500ms ease",
                shine: "shine 8s ease infinite",
                marquee: "marquee 20s linear infinite",
                "marquee-vertical": "marquee-vertical 20s linear infinite",
              },
            },
          },
          plugins: [`require("tailwindcss-animate")`],
        },
      },
      cssVars: {},
      files: [],
    };

    await fs.writeFile(
      path.join(targetPath, "index.json"),
      JSON.stringify(payload, null, 2),
      "utf8"
    );
  }
}
// ----------------------------------------------------------------------------
// Base CSS template for Tailwind
const BASE_STYLES = `@tailwind base;
@tailwind components;
@tailwind utilities;
`;

// Base CSS template with CSS variables
const BASE_STYLES_WITH_VARIABLES = `@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: <%- colors.light["background"] %>;
    --foreground: <%- colors.light["foreground"] %>;
    --card: <%- colors.light["card"] %>;
    --card-foreground: <%- colors.light["card-foreground"] %>;
    --popover: <%- colors.light["popover"] %>;
    --popover-foreground: <%- colors.light["popover-foreground"] %>;
    --primary: <%- colors.light["primary"] %>;
    --primary-foreground: <%- colors.light["primary-foreground"] %>;
    --secondary: <%- colors.light["secondary"] %>;
    --secondary-foreground: <%- colors.light["secondary-foreground"] %>;
    --muted: <%- colors.light["muted"] %>;
    --muted-foreground: <%- colors.light["muted-foreground"] %>;
    --accent: <%- colors.light["accent"] %>;
    --accent-foreground: <%- colors.light["accent-foreground"] %>;
    --destructive: <%- colors.light["destructive"] %>;
    --destructive-foreground: <%- colors.light["destructive-foreground"] %>;
    --border: <%- colors.light["border"] %>;
    --input: <%- colors.light["input"] %>;
    --ring: <%- colors.light["ring"] %>;
    --radius: 0.5rem;
  }

  .dark {
    --background: <%- colors.dark["background"] %>;
    --foreground: <%- colors.dark["foreground"] %>;
    --card: <%- colors.dark["card"] %>;
    --card-foreground: <%- colors.dark["card-foreground"] %>;
    --popover: <%- colors.dark["popover"] %>;
    --popover-foreground: <%- colors.dark["popover-foreground"] %>;
    --primary: <%- colors.dark["primary"] %>;
    --primary-foreground: <%- colors.dark["primary-foreground"] %>;
    --secondary: <%- colors.dark["secondary"] %>;
    --secondary-foreground: <%- colors.dark["secondary-foreground"] %>;
    --muted: <%- colors.dark["muted"] %>;
    --muted-foreground: <%- colors.dark["muted-foreground"] %>;
    --accent: <%- colors.dark["accent"] %>;
    --accent-foreground: <%- colors.dark["accent-foreground"] %>;
    --destructive: <%- colors.dark["destructive"] %>;
    --destructive-foreground: <%- colors.dark["destructive-foreground"] %>;
    --border: <%- colors.dark["border"] %>;
    --input: <%- colors.dark["input"] %>;
    --ring: <%- colors.dark["ring"] %>;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}`;

async function buildThemes() {
  const themesTargetPath = path.join(REGISTRY_PATH, "themes");
  const colorsTargetPath = path.join(REGISTRY_PATH, "colors");

  // Clean up existing directories
  rimraf.sync(themesTargetPath);
  rimraf.sync(colorsTargetPath);

  // Create fresh directories
  await fs.mkdir(themesTargetPath, { recursive: true });
  await fs.mkdir(colorsTargetPath, { recursive: true });

  // Generate theme CSS variables
  let themeCSS = `
/* This file is auto-generated by scripts/build-themes.ts */
/* Do not edit directly */\n\n`;

  // Process each theme
  for (const theme of themes) {
    const { name, cssVars, cssVarsV4 } = theme;

    // Create complete theme JSON representation
    const themeJson = {
      type: "registry:theme",
      name,
      label: theme.label,
      activeColor: theme.activeColor,
      cssVars,
      cssVarsV4,
      inlineColorsTemplate: template(BASE_STYLES)({}),
      cssVarsTemplate: template(BASE_STYLES_WITH_VARIABLES)({
        colors: cssVars,
      }),
    };

    // Write theme JSON file
    await fs.writeFile(
      path.join(themesTargetPath, `${name}.json`),
      JSON.stringify(themeJson, null, 2),
      "utf8"
    );

    // Generate CSS variables for this theme
    themeCSS += generateThemeCSS(name, cssVars);

    // Create color JSON file for v4 compatibility
    const colorJson = {
      name,
      cssVars,
      cssVarsV4,
    };

    await fs.writeFile(
      path.join(colorsTargetPath, `${name}.json`),
      JSON.stringify(colorJson, null, 2),
      "utf8"
    );
  }

  // Write combined themes.css
  await fs.writeFile(path.join(REGISTRY_PATH, "themes.css"), themeCSS, "utf8");

  // Create colors/index.json with all color data
  const colorsIndex = {
    themes: themes.map((theme) => ({
      name: theme.name,
      label: theme.label,
      activeColor: theme.activeColor,
    })),
  };

  const themesIndex = {
    themes: themes.map((theme) => ({
      name: theme.name,
      label: theme.label,
      activeColor: theme.activeColor,
    })),
  };
  // Write themes/index.json
  await fs.writeFile(
    path.join(themesTargetPath, "index.json"),
    JSON.stringify(themesIndex, null, 2),
    "utf8"
  );

  await fs.writeFile(
    path.join(colorsTargetPath, "index.json"),
    JSON.stringify(colorsIndex, null, 2),
    "utf8"
  );
}

function generateThemeCSS(themeName: string, cssVars: any) {
  return `
.theme-${themeName} {
  --background: ${cssVars.light.background};
  --foreground: ${cssVars.light.foreground};
  --card: ${cssVars.light.card};
  --card-foreground: ${cssVars.light["card-foreground"]};
  --popover: ${cssVars.light.popover};
  --popover-foreground: ${cssVars.light["popover-foreground"]};
  --primary: ${cssVars.light.primary};
  --primary-foreground: ${cssVars.light["primary-foreground"]};
  --secondary: ${cssVars.light.secondary};
  --secondary-foreground: ${cssVars.light["secondary-foreground"]};
  --muted: ${cssVars.light.muted};
  --muted-foreground: ${cssVars.light["muted-foreground"]};
  --accent: ${cssVars.light.accent};
  --accent-foreground: ${cssVars.light["accent-foreground"]};
  --destructive: ${cssVars.light.destructive};
  --destructive-foreground: ${cssVars.light["destructive-foreground"]};
  --border: ${cssVars.light.border};
  --input: ${cssVars.light.input};
  --ring: ${cssVars.light.ring};
  --radius: ${cssVars.light.radius || "0.5rem"};
}

.dark .theme-${themeName} {
  --background: ${cssVars.dark.background};
  --foreground: ${cssVars.dark.foreground};
  --card: ${cssVars.dark.card};
  --card-foreground: ${cssVars.dark["card-foreground"]};
  --popover: ${cssVars.dark.popover};
  --popover-foreground: ${cssVars.dark["popover-foreground"]};
  --primary: ${cssVars.dark.primary};
  --primary-foreground: ${cssVars.dark["primary-foreground"]};
  --secondary: ${cssVars.dark.secondary};
  --secondary-foreground: ${cssVars.dark["secondary-foreground"]};
  --muted: ${cssVars.dark.muted};
  --muted-foreground: ${cssVars.dark["muted-foreground"]};
  --accent: ${cssVars.dark.accent};
  --accent-foreground: ${cssVars.dark["accent-foreground"]};
  --destructive: ${cssVars.dark.destructive};
  --destructive-foreground: ${cssVars.dark["destructive-foreground"]};
  --border: ${cssVars.dark.border};
  --input: ${cssVars.dark.input};
  --ring: ${cssVars.dark.ring};
}\n\n`;
}

// ----------------------------------------------------------------------------
// Build registry/icons/index.json.
// ----------------------------------------------------------------------------
async function buildIcons() {
  const iconsTargetPath = path.join(REGISTRY_PATH, "icons");
  rimraf.sync(iconsTargetPath);
  if (!existsSync(iconsTargetPath)) {
    await fs.mkdir(iconsTargetPath, { recursive: true });
  }

  const iconsData = icons;

  await fs.writeFile(
    path.join(iconsTargetPath, "index.json"),
    JSON.stringify(iconsData, null, 2),
    "utf8"
  );
}

// ----------------------------------------------------------------------------
// Build __registry__/icons.tsx.
// ----------------------------------------------------------------------------
async function buildRegistryIcons() {
  let index = `// @ts-nocheck
// This file is autogenerated by scripts/build-registry.ts
// Do not edit this file directly.
import * as React from "react"

export const Icons = {
`;

  for (const [icon, libraries] of Object.entries(icons)) {
    index += `  "${icon}": {`;
    for (const [library, componentName] of Object.entries(libraries)) {
      const packageName = iconLibraries[library].package;
      if (packageName) {
        index += `
  ${library}: React.lazy(() => import("${packageName}").then(mod => ({
    default: mod.${componentName}
  }))),`;
      }
    }
    index += `
},`;
  }

  index += `
}
`;

  // Write style index.
  rimraf.sync(path.join(process.cwd(), "__registry__/icons.tsx"));
  await fs.writeFile(
    path.join(process.cwd(), "__registry__/icons.tsx"),
    index,
    "utf8"
  );
}

try {
  console.log("💽 Building registry...");
  const result = registrySchema.safeParse(registry);

  if (!result.success) {
    console.error(result.error);
    process.exit(1);
  }

  await syncStyles();
  await buildRegistry(result.data);
  await buildStyles(result.data);
  await buildStylesIndex();
  await buildThemes();
  await buildRegistryIcons();
  await buildIcons();
  await buildRegistryJsonFile();

  console.log("✅ Done!");
} catch (error) {
  console.error(error);
  process.exit(1);
}
